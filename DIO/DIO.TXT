BootCamp Bradesco 2025

                Introdu√ß√£o √† plataforma Java:

Pilares POO - Classes e objetos, Encapsulamento, Abstra√ß√£o, Heran√ßa, Polimorfismo

C√≥digo -> Bytecode -> ....

Bytecode e JVM tornam o Java 

A JVM transforma o Bytecode em algoritmo que ser√° interpretado pelo sistema!

WORA (Write once, run anywhere)

Robustez: Gerenciamento de mem√≥ria forte, coleta de lixo, tratamento de exce√ß√£o e mecanismos de verifica√ß√£o de tipo de dados

Seguran√ßa: Recursos de criptografia e descriptografia

Java compila gerando Bytecode e a JVM (Java Virtual Machine) interpreta o arquivo em Bytecode durante a execu√ß√£o

Thread = subprocesso leve e independente de um programa em execu√ß√£o, Java √© multithread logo possui v√°rios threads sendo executados simultaneamente

Java = Cidade de origem de um tipo de caf√© 


                Ambiente de desenvolvimento Java

Fun√ß√µes com autocomplete e inteliSense, formata√ß√£o de palavras e blocos de C√≥digo, an√°lises de erro de sintaxe, compila√ß√£o de programas e depura√ß√£o (acompanhamento) de execu√ß√£o do programa

IDeS principais: Eclipse, Netbeans, Intellij, Vscode

Maven = Umas das formas de empacotamento de projetos em java, ferramenta de automa√ß√£o de compila√ß√£o tamb√©m usada para construir e gerenciar projetos escritos em C#, Ruby, Scala, e outras linguagens

Snippet = Termo de programa√ß√£o para uma pequena regi√£o de c√≥digo-fonte reutiliz√°vel, c√≥digo de m√°quina ou texto. Normalmente, estas s√£o unidades operacionais formalmente definidas para serem incorporadas em m√≥dulos de programa√ß√£o maiores.

Instalar o JDK (Vscode automotiza com o Java Coding pack, que inclui o Vscode, JDK e extens√µes √∫teis e essenciais!) ele tamb√©m pode ser usado para atualizar um Vscode sem o JDK e as extens√µes!

O Eclipse possui vers√µes (packages) para desenvolvimento Java puro e uma vers√£o espec√≠fica para desenvolvimento Web! a escolha de diret√≥rio no Eclipse √© meio chata, mas uma conven√ß√£o legal √©: c/dev/ws/'trabalho' / dev de desenvolvimento, ws de workspace! e c/dev/projetos/'projeto' para projetos!


JDK PATH = c://Arquivos de Programas / Java / JDK (v√°rias vers√µes?)

No CMD 'java -version' retorna a vers√£o atual do Java instalado

Todo projeto Java sem um sistema de gerenciamento de projetos (como o Maven) possui pastas como 'lib', 'src' e arquivos que documentam a estrutura do projeto como um todo como o 'readme' que inclui informa√ß√µes sobre o projeto

A integra√ß√£o do Vscode com o Github, permite usar o Gitclone no Vscode para clonar nossos reposit√≥rios, CTRL + SHIFT + P para criar novos projetos Java e ver outras funcionalidades!

JRE (Java Runtime Enviroment) √© necess√°rio apenas para rodar c√≥digo Java, e n√£o desenvolver!

As quatro principais plataformas de desenvolvimento Java s√£o: 
Java SE (Java Platform, Standard Edition)
Java EE (Java Platform, Enterprise Edition)
Java ME (Java Platform, Micro Edition)
Java FX

                Versionamento de C√≥digo com Git e GitHub 

Controlam as vers√µes de um arquivo ao longo do tempo, registram hist√≥rico de atualiza√ß√µes do arquivo, gerenciam quais foram as altera√ß√µes, datas, autores e etc. Organiza√ß√£o, Controle e Seguran√ßa

Tipos: VCS Centralizado (CVCS) = Centralizam os dados em um servidor <- se ficar fora do ar o projeto fica inacess√≠vel, se houver perca de dados (e tu n√£o tiver backup) todo o projeto √© perdido

VCS Distribuido (DVCS) = Clona o reposit√≥rio incluindo o hist√≥rico de vers√µes, cada clone √© como um backup, possibilita fluxo de trabalho flexivel, possibilita trabalhar sem rede de internet!

O Git √© um sistema de controle de vers√£o distribu√≠do amplamente usado por desenvolvedores para gerenciar projetos de software. Ele permite que voc√™ acompanhe mudan√ßas no c√≥digo, trabalhe em equipe simultaneamente e volte a vers√µes anteriores quando necess√°rio. O Git organiza o hist√≥rico de altera√ß√µes em "commits", facilitando o rastreamento e a colabora√ß√£o eficiente. Com ele, voc√™ pode criar ramifica√ß√µes (branches) para desenvolver novos recursos ou corrigir bugs sem afetar o c√≥digo principal. 

git clone -> Clona um reposit√≥rio git existente para um novo diret√≥rio local
git commit -> Salva as altera√ß√µes no reposit√≥rio
git pull -> Puxa as altera√ß√µes do reposit√≥rio remoto para o local (busca e mescla)
git push -> Empurra as altera√ß√µes do reposit√≥rio local para o remoto
commit -> pull -> push
git --version no CMD pra ver a vers√£o do Git

GitBash (Aberto em algum diret√≥rio) permite usar comandos para configurar o Git / CTRL + L limpa o terminal!
git config - permite ver altera√ß√µes, tais como alterar as vari√°veis de configura√ß√£o

Como todos os nossos reposit√≥rios tem de estar em nosso nome as altera√ß√µes devem estar em escopo global

git config --global user.name "Fulano" / Definir o nome do usu√°rio
git config --global user.email fulano@gmail.com / Definir o email do usu√°rio
Ambos comandos sem argumentos (nome ou email) v√£o retornar os nomes e emails respectivamente usados

Esses dados ser√£o vinculados aos commits, mudar o nome ou email n√£o ir√° alterar commits j√° feitos!

git config init.defaultBranch / Retorna o nome da branch
git config --global init.defaultBranch algo / Muda o nome da branch para 'algo'

git config --global --list / Lista todas as configura√ß√µes globais (sem o global ia mostrar tudo)

O Github √© uma plataforma de hospedagem de c√≥digo para controle de vers√£o com Git e colabora√ß√£o

(Ela fez o login no Git com o Token do Github??)
N√≥s usamos SSH para logar (Secure Shell) OU N√ÉO?

git config --global credential.helper store / Salva as cred√™nciais 
git config --global credential.helper cache / Salva temporariamente (util se dividir a m√°quina)
git config --global credential.helper / Mostra como est√° salvando

git config --global --show-origin credential.helper / Mostra onde as cred√™nciais est√£o salvas e o 'modo' dela

Criando e Clonando Reposit√≥rios

Existem duas formas de obter um reposit√≥rio Git na sua m√°quina: 1. Transformando um diret√≥rio local que n√£o est√° sob controle de vers√£o, num reposit√≥rio Git; 2. Clonando um reposit√≥rio Git existente

Comandos do GitBash
1¬∞
mkdir repo-local / Cria o diret√≥rio 'repo-local'
cd repo-local / Muda o diret√≥rio para 'repo-local'
git init / Transforma o diret√≥rio atual em um reposit√≥rio git (main)
cd .git / Muda o diret√≥rio para 'git' (git_dir)
ls / Lista os arquivos (entre eles h√° um arquivo de configura√ß√µes)
cat config / Mostra os dados do arquivo de configura√ß√µes mencionado.

2¬∞
Copia-se o c√≥digo https do reposit√≥rio no Github
git clone 'url' / Copia o reposit√≥rio da url
git clone 'url' 'nome' / Copia o reposit√≥rio da url e muda o nome da pasta para 'nome'


git remote -v / Mostra os reposit√≥rios remotos aos quais est√° vinculado
git remote add 'nome' 'url do reposit√≥rio ao qual queremos vincular' (padr√£o deixar o nome 'origin') / Conecta o reposit√≥rio local com um reposit√≥rio remoto

git clone 'url' --branch 'nome-da-branch' --single-branch / Clona apenas a branch escolhida pelo nome, se n√£o passar o nome ele clona a principal seja a 'main' ou a 'master'

git status / √© utilizado para verificar o estado atual do reposit√≥rio Git. Ele informa quais mudan√ßas foram realizadas, quais arquivos est√£o no estado "staged" (prontos para serem commitados), quais est√£o modificados mas ainda n√£o "staged", e tamb√©m destaca quaisquer arquivos n√£o rastreados

Untracked files / Esses s√£o arquivos que est√£o no diret√≥rio do seu projeto, mas o Git ainda n√£o est√° rastreando. Eles n√£o fazem parte de nenhum commit. Para come√ßar a rastre√°-los, voc√™ precisa adicion√°-los √† √°rea de stage usando git add.

Modified files / S√£o arquivos que foram alterados desde o √∫ltimo commit, mas ainda n√£o foram adicionados √† √°rea de stage. Voc√™ pode prepar√°-los para o commit usando git add ou deix√°-los como est√£o enquanto continua trabalhando neles.

Staged files / Esses arquivos foram adicionados √† √°rea de stage e est√£o prontos para serem inclu√≠dos no pr√≥ximo commit. Um commit grava essas altera√ß√µes no hist√≥rico do reposit√≥rio.

Markdown / Markdown √© uma linguagem de marca√ß√£o leve e simples, criada para formatar texto de forma f√°cil e leg√≠vel. Com ela, voc√™ pode criar documentos estruturados que incluem cabe√ßalhos, listas, tabelas, links, imagens e mais, sem precisar de um editor de texto complexo. O destaque do Markdown √© que o texto ainda √© leg√≠vel sem renderiza√ß√£o, o que facilita tanto a escrita quanto a colabora√ß√£o.

Use o https://readme.so/pt para criar arquivos README decentes com linguagem markdown, um exemplo disso ser√° visto no README do "Primeiro-Projeto-Java", use WINDOWS + . para usar emojis!

git add 'arquivo.txt' / √© usado para adicionar arquivos ou mudan√ßas ao "stage" (√°rea de prepara√ß√£o), deixando-os prontos para serem inclu√≠dos no pr√≥ximo commit. Em resumo, ele coloca suas altera√ß√µes sob rastreamento do Git, git add . adiciona TODOS os arquivos

git commit / √© usado para criar um commit, que registra as altera√ß√µes preparadas na √°rea de stage no hist√≥rico do reposit√≥rio. O -m permite que voc√™ inclua uma mensagem descritiva diretamente no comando, explicando o que foi alterado. √â uma pr√°tica recomendada escrever mensagens claras e informativas para facilitar o entendimento no futuro. git commit -m "Adiciona funcionalidade X ao projeto"

git log / O comando git log √© usado para visualizar o hist√≥rico de commits do reposit√≥rio. Ele lista os commits feitos, mostrando informa√ß√µes como o autor, a data e a mensagem associada a cada commit. √â uma maneira de revisar o progresso do projeto, possui varia√ß√µes que incluem 1 linha ou mais, pesquise!

touch arquivo.txt /  usado principalmente em sistemas baseados em Unix (como Linux e macOS) para criar arquivos vazios ou atualizar a data e hora de modifica√ß√£o de um arquivo existente.

O git reconhece pastas vazias, alguns projetos possuem o arquivo gitkeep.txt dentro de diret√≥rios, isso serve para o git reconhecer os diret√≥rios

Desfazendo altera√ß√µes 

Vamos supor que voc√™ deu git init na pasta errada, era pra ser  /Nova pasta, mas voc√™ colocou /Nova pasta/.git/, para remover isso basta usar
rm - rf .git
e o sistema voltar√° para Nova

Se apagarmos ou alterarmos um arquivo o git status indicar√° a mudan√ßa! caso queiramos reverter ela basta usar
git restore arquivo.md
CUIDADO, ele descarta todas as altera√ß√µes feitas localmente!

Alterar mensagem de commit (que por sua vez aparece no git log)
git commit --amend -m"mensagem nova!"

desfazer commit
git reset --soft 'hashcode'
git reset --mixed 'hashcode'
git reset --hard  'hashcode'

soft / Mant√©m as mudan√ßas na √°rea de stage (prontas para o pr√≥ximo commit). √ötil se voc√™ quer desfazer um commit mas preparar as mesmas altera√ß√µes para um novo commit. Isso desfaz o √∫ltimo commit, mas deixa os arquivos prontos para serem commitados novamente.

mixed / Remove as altera√ß√µes da √°rea de stage, mas as mant√©m nos arquivos de trabalho. √ötil se voc√™ quer fazer ajustes antes de preparar os arquivos novamente. Isso desfaz o commit e remove os arquivos da √°rea de stage, mas mant√©m os arquivos modificados.

hard / Desfaz o commit e descarta completamente as altera√ß√µes nos arquivos. Desfaz o commit e descarta completamente as altera√ß√µes nos arquivos. Isso desfaz o √∫ltimo commit e retorna o reposit√≥rio ao estado anterior, descartando todas as mudan√ßas

git reflog / √© usado para visualizar o hist√≥rico de refer√™ncias de um reposit√≥rio. Ele exibe uma lista de altera√ß√µes feitas nas refer√™ncias do Git (como commits, resets, merges, etc.), permitindo que voc√™ veja e recupere estados anteriores mesmo que tenham sido descartados do log normal. Ele ajuda a rastrear commits "perdidos" ou que foram sobrescritos. Pode ser usado para recuperar altera√ß√µes depois de comandos como git reset --hard. (Cima = mais recente, baixo = menos recente!)

For√ßar altera√ß√µes nos commits pode causar problemas. √â recomendado corrigir os problemas criando um novo commit!

Abrir um reposit√≥rio no github e apertar a tecla '.' vai abrir o projeto em um 'vscode online'!

branches
Ou branch √© uma ramifica√ß√£o do projeto, um ponteiro m√≥vel para um commit no hist√≥rico do reposit√≥rio, quando voc√™ cria uma nova branch a partir de outra existente, a nova se inicia apontando para o mesmo commit da branch que estava quando foi 

commit 0 <-- commit 1 <-- commit 2(branch main)

a branch aponta para o commit 2, mas ele por si s√≥ aponta para o commit anterior
Quando se trabalha com m√∫ltiplas branches em um reposit√≥rio Git, cada branch representa uma linha de desenvolvimento independente. Isso permite que diferentes altera√ß√µes ou funcionalidades sejam desenvolvidas paralelamente sem interferir nas outras. Aqui est√° como funciona, Cada branch tem seu pr√≥prio ponteiro para um commit. Por exemplo:

main (commit 5) <-- commit 4 <-- commit 3
feature-x (commit 6) <-- commit 4 <-- commit 3

Nesse caso, main e feature-x compartilham parte do hist√≥rico, mas depois divergem

git checkout / √© usado principalmente para trocar entre branches ou restaurar arquivos, mas pode ter v√°rias funcionalidades dependendo do contexto. Aqui est√£o os usos mais comuns:

Trocar entre branches: git checkout nome-da-branch

Criar e mudar para uma nova branch: git checkout -b nova-

Restaurar arquivos ao estado de um commit espec√≠fico:
git checkout HEAD arquivo.txt
Isso restaura o arquivo ao √∫ltimo estado commitado.

Restaurar o estado de todo o diret√≥rio:
Caso queira desfazer todas as altera√ß√µes n√£o commitadas
git checkout HEAD .

git merge / O git merge serve para integrar as mudan√ßas de uma branch em outra. Ele preserva o hist√≥rico de commits e une os trabalhos de diferentes desenvolvedores ou funcionalidades.
- Se n√£o houver novos commits na branch de destino, o Fast-forward Merge √© usado: ele simplesmente avan√ßa o ponteiro da branch sem criar um novo commit.
- Caso ambas as branches tenham novos commits, um Merge Commit √© criado para registrar a combina√ß√£o de mudan√ßas.
- Se houver altera√ß√µes conflitantes (ex.: o mesmo arquivo editado em ambas as branches), o Git solicita que voc√™ resolva manualmente antes de concluir o merge.

Exemplo b√°sico:
git checkout main
git merge feature-x

Aqui, a branch feature-x ser√° mesclada na main.

git fetch / O comando git fetch √© usado para baixar atualiza√ß√µes de branches remotas (como commits, tags e metadados) para o reposit√≥rio local, sem alterar as branches locais ou fazer merges. Ele sincroniza o reposit√≥rio local com o remoto, permitindo que voc√™ veja as mudan√ßas antes de aplic√°-las ou integr√°-las. Por exemplo, ap√≥s um git fetch, voc√™ pode comparar as diferen√ßas ou decidir fazer um merge ou rebase manualmente 

Para buscar de uma branch remota espec√≠fica:
git fetch origin nome-da-branch

Para buscar de um reposit√≥rio remoto espec√≠fico (caso voc√™ tenha configurado mais de um):
git fetch nome-do-remoto

Por padr√£o, o git fetch pega todas as atualiza√ß√µes do reposit√≥rio remoto associado (geralmente chamado de origin). Isso n√£o altera sua branch local at√© que voc√™ decida aplicar as mudan√ßas, como com git merge ou git pull.

Se criam uma issue de n√∫mero 1, ao arrumarmos e darmos commit na solu√ß√£o do problema, usamos fix #1 no nome do commit, dessa forma corrigimos a issue de n√∫mero 1


                Sintaxe Java (S√≥ vou anotar o que n√£o sei/lembro)


Cuidado com o CamelCase e etc, essas paradas de nomea√ß√£o de classes, arquivos e etc. Normalmente vari√°veis tipo FINAL, PI, EXEMPLO (toda em ma√≠uscula) indicam vari√°veis que n√£o podem ser alteradas, uma vari√°vel int no estilo ANO_2000 por si s√≥ j√° indica que √© 2000 e n√£o deve ser alteradas

Come√ßo de vari√°veis: letras, $, _ 

express√£o Final em vari√°vel indica que ela n√£o pode ser alterada = constante!

Nomea√ß√£o de pacotes: imagine uma empresa chamada HyperTech, ela possui v√°rios setores, se o setor de comercio for fazer um projeto, seria legal usar esse padr√£o
com.hypertech.'nomeDoProjeto'
com de comercio, e por ai vai, e podemos ter 
com.hypertech.'nomeDoProjeto'.app pra inicializar
com.hypertech.'nomeDoProjeto'.modelo pra por as classes de modelo
com.hypertech.'nomeDoProjeto'.util para guardar os utilit√°rios
com.hypertech.'nomeDoProjeto'.services com regras de neg√≥cio e servi√ßo
A CONVEN√á√ÉO VARIA DE EMPRESA PARA EMPRESA

e por ai vai, os pacotes (pastas) servem para ajudar a organizar os dados!

JavaBeans s√£o componentes reutiliz√°veis da plataforma Java que encapsulam dados e l√≥gica de neg√≥cios, facilitando a comunica√ß√£o entre diferentes partes de uma aplica√ß√£o

Vari√°vel no plural s√≥ se for um arrray de coisas

Fun√ß√µes com nomes de verbo, concluirProcessamento, Somar e por ai vai

float se encerra com F, float pi = 3.14F (f ou F)

JavaDoc √© uma ferramenta utilizada para gerar documenta√ß√£o de c√≥digo em Java com base em coment√°rios no formato especial, facilitando a leitura e compreens√£o das funcionalidades de uma aplica√ß√£o.

pra executar app fora da IDE √© s√≥ achar a pasta bin com o .class que queremos rodar atrav√©s do poweshell ou ms-dos e dar 'java exemplo' sem o .class

Quando voc√™ usa o comando javac para compilar um arquivo-fonte Java (.java), ele gera um arquivo de bytecode Java (.class). Esse arquivo .class cont√©m o c√≥digo que a M√°quina Virtual Java (JVM) pode interpretar e executar.
Se, por exemplo, voc√™ tiver um arquivo Programa.java, ao rodar javac Programa.java, o compilador criar√° Programa.class. Depois, voc√™ pode executar esse programa com java Programa.

- Recebendo Argumentos: O m√©todo main define um par√¢metro String[] args, que √© um array de strings contendo os argumentos passados quando o programa √© executado.
- Atribui√ß√£o de Valores: O programa extrai os valores dos argumentos fornecidos:- args[0]: O primeiro argumento √© armazenado na vari√°vel nome.
- args[1]: O segundo argumento √© armazenado na vari√°vel sobrenome.
- args[2]: O terceiro argumento, que representa a idade, √© convertido para um n√∫mero inteiro (int).
- args[3]: O quarto argumento, que representa a altura, √© convertido para um n√∫mero decimal (double).

- Exibi√ß√£o na Tela: Utilizando System.out.println(), o programa imprime:- Uma sauda√ß√£o com o nome e sobrenome.
- A idade informada.
- A altura informada em cent√≠metros.

EXEMPLO:
public class Programa {
    public static void main(String[] args) {
        // Obtendo os argumentos da linha de comando
        String nome = args[0];
        String sobrenome = args[1];
        int idade = Integer.parseInt(args[2]);
        double altura = Double.parseDouble(args[3]);

        // Exibindo as informa√ß√µes
        System.out.println("Ol√°, me chamo " + nome + " " + sobrenome);
        System.out.println("Tenho " + idade + " anos");
        System.out.println("Minha altura √© " + altura + " cm");
    }
}
(√© de se esperar que tudo seja String, ent√£o por isso o Parse nos outros tipos de dados!)

Se executarmos o programa com os seguintes argumentos:
java Programa Carlos Silva 25 175.5

Ele gerar√° a seguinte sa√≠da:
Ola, me chamo Carlos Silva
Tenho 25 anos
Minha altura √© 175.5 cm

Dentro de um projeto Java no Vscode h√° uma pasta chamada .vscode que cont√©m um arquivo launch.json, l√° podemos definir os argumentos iniciais de execu√ß√£o de um programa!

Erros de programa√ß√£o s√£o denominados bugs e o processo de encontrar e corrigir bugs √© chamado de depura√ß√£o ou debugging.

Existem duas grandes categorias que englobam a natureza do erro:

Erros de Sintaxe:
√â um erro nas regras estabelecidas da linguagem:
Par√™nteses, chaves, colchetes que abrem mas n√£o fecham.
Duas instru√ß√µes sem um ponto-e-v√≠rgula entre elas;
Uma palavra-chave sendo usada numa posi√ß√£o inesperada.

Erros de Sem√¢ntica:
√â um erro na "l√≥gica do c√≥digo", em sua sem√¢ntica, o c√≥digo est√° sintaticamente correto, por√©m n√£o faz o que se esperava dele.
Tentar dividir um n√∫mero por uma String ou por zero.
Atribuir um valor incoerente a um tipo de dado.
Tentar fechar um arquivo que n√£o foi aberto.

Depura√ß√£o/Debugging
Linguagens de alto n√≠vel tornam a depura√ß√£o mais f√°cil, pois fornecem mais ferramentas para identificar erros, como o tratamento de exce√ß√µes.

Os depuradores funcionam assumindo o controle do tempo de execu√ß√£o de um programa e permitindo que voc√™ o observe e controle. Para fazer isso, ele mostra a pilha do programa e permite que voc√™ a atravesse em qualquer dire√ß√£o. Quando voc√™ est√° em um depurador, obt√©m uma imagem mais completa de um quadro de pilha do que quando olha os rastreamentos de pilha em uma mensagem de log.

Pilha de Execu√ß√£o de um Programa Java/Stack Trace
Pilha de Execu√ß√£o:
Toda invoca√ß√£o de m√©todo √© empilhada em uma estrutura de dados que isola a √°rea de mem√≥ria de cada um. Quando um m√©todo termina (retorna), ele volta para o m√©todo que o invocou.

Stack Trace:
√â a matriz onde encontramos a pilha de excecu√ß√£o da exce√ß√£o. Em outras palavras, podemos dizer que o rastreamento da pilha busca (rastreio) para a pr√≥xima linha onde a exce√ß√£o pode surgir.

Lemos a stack trace de baixo para cima!

Tread.dumpStack() imprime o rastreamento da pilha da thread atual no fluxo de erro padr√£o. Isso √© √∫til para depura√ß√£o, pois permite verificar onde uma thread est√° sendo executada em determinado momento.

Breakpoints s√£o essenciais para depura√ß√£o em Java! Eles permitem que voc√™ pause a execu√ß√£o do programa em um ponto espec√≠fico e analise o estado das vari√°veis e do fluxo de execu√ß√£o. Aqui est√£o alguns passos para us√°-los em um ambiente de desenvolvimento como o IntelliJ IDEA ou Eclipse:
- Definir um breakpoint ‚Äì Clique na margem esquerda ao lado de uma linha de c√≥digo onde deseja que a execu√ß√£o pare.
- Executar o programa no modo de depura√ß√£o ‚Äì Use a op√ß√£o de "Debug" ao inv√©s de "Run".
- Inspecionar vari√°veis ‚Äì Quando o programa parar no breakpoint, voc√™ pode examinar valores de vari√°veis no painel de depura√ß√£o.
- Passar pelas linhas ‚Äì Use os comandos "Step Over", "Step Into" e "Step Out" para navegar pelo c√≥digo.
- Modificar valores durante a execu√ß√£o ‚Äì Alguns IDEs permitem alterar valores de vari√°veis no meio da execu√ß√£o para testar diferentes cen√°rios.

 Esses comandos de depura√ß√£o ajudam a navegar pelo c√≥digo em um ambiente de debug. Aqui est√° o que cada um faz:

Step Over (F8 no IntelliJ IDEA, F6 no Eclipse): Avan√ßa para a pr√≥xima linha de c√≥digo sem entrar em m√©todos chamados na linha atual. Se houver uma chamada de m√©todo, ele ser√° executado inteiramente e o depurador passar√° para a pr√≥xima linha no mesmo escopo.

Step Into (F7 no IntelliJ IDEA, F5 no Eclipse): Entra no m√©todo chamado na linha atual, permitindo inspecionar sua execu√ß√£o linha por linha.

Force Step Into (Alt + Shift + F7 no IntelliJ IDEA): Ignora otimiza√ß√µes da IDE e entra at√© mesmo em m√©todos da biblioteca padr√£o ou c√≥digo compilado.

Step Out (Shift + F8 no IntelliJ IDEA, F7 no Eclipse): Sai do m√©todo atual e retorna ao seu chamador, √∫til para concluir rapidamente um m√©todo e voltar ao n√≠vel superior.

Run to Cursor (Alt + F9 no IntelliJ IDEA, Ctrl + R no Eclipse): Continua a execu√ß√£o at√© o ponto onde o cursor est√°, sem a necessidade de um breakpoint.

O Evaluate Expression √© uma ferramenta muito √∫til na depura√ß√£o de c√≥digo Java! Ele permite que voc√™ avalie express√µes ou execute pequenas por√ß√µes de c√≥digo no contexto da execu√ß√£o atual do depurador, sem alterar o c√≥digo-fonte.
Aqui est√£o alguns usos comuns:
- Verificar valores complexos ‚Äì Voc√™ pode inserir qualquer express√£o, como myObject.getSomeValue() e visualizar o resultado sem precisar imprimir no console.
- Modificar valores temporariamente ‚Äì √â poss√≠vel alterar vari√°veis no meio da execu√ß√£o para testar diferentes cen√°rios.
- Testar chamadas de m√©todos ‚Äì Avalie um m√©todo antes de execut√°-lo no c√≥digo principal, garantindo que ele retorna o valor esperado.
- Express√µes booleanas ‚Äì Confirme rapidamente se uma condi√ß√£o if ser√° verdadeira ou falsa antes de prosseguir.

Ao debuggar pode ser necess√°rio inserir dados no console, confirmar  e apertar em step over para seguir a l√≥gica do programa

--
Jeito de aceitar v√≠rgulas e pontos 

Scanner scanner = new Scanner(System.in);
System.out.print("Digite um n√∫mero decimal: ");
String input = scanner.nextLine().replace(",", "."); // L√™ como string e substitui v√≠rgula por ponto

try {
    double numero = Double.parseDouble(input); // Faz o parse para Double
    System.out.println("N√∫mero convertido: " + numero);
} catch (NumberFormatException e) {
    System.out.println("Entrada inv√°lida!");
}

s√≥ pegar o input como string trocar a , por . e dar um parse depois!

Em Java, especialmente em projetos que seguem padr√µes como a arquitetura em camadas (comum em aplica√ß√µes Spring, por exemplo), h√° uma s√©rie de conven√ß√µes para nomear e organizar classes com base em suas responsabilidades. Essas conven√ß√µes ajudam a manter o c√≥digo limpo, organizado e mais f√°cil de manter. Abaixo, explico as principais categorias de classes e suas conven√ß√µes:

1. Modelos (Model / Entity)
Fun√ß√£o: Representam entidades do dom√≠nio do neg√≥cio. Geralmente correspondem a tabelas em um banco de dados.

Conven√ß√µes:

Nome no singular e representativo do conceito de neg√≥cio: User, Product, Order.

Normalmente anotadas com @Entity (em JPA/Hibernate).

Cont√™m atributos com getters/setters, construtores e m√©todos auxiliares (como equals() e hashCode()).

2. Reposit√≥rios (Repository / DAO)
Fun√ß√£o: Respons√°veis pelo acesso a dados (CRUD ‚Äì Create, Read, Update, Delete).

Conven√ß√µes:

Interface com sufixo Repository ou Dao: UserRepository, ProductDao.

Usualmente estendem interfaces como JpaRepository, CrudRepository, etc.

Anotados com @Repository (no Spring).

N√£o cont√™m regras de neg√≥cio, apenas opera√ß√µes de persist√™ncia.

3. Servi√ßos (Service)
Fun√ß√£o: Cont√™m a l√≥gica de neg√≥cio da aplica√ß√£o.

Conven√ß√µes:

Nome com sufixo Service: UserService, PaymentService.

Normalmente anotadas com @Service.

Chamam m√©todos de reposit√≥rios e manipulam entidades.

Implementam regras de neg√≥cio, valida√ß√µes e orquestra√ß√µes de processos.

4. Controladores (Controller)
Fun√ß√£o: Camada de entrada da aplica√ß√£o. Lidam com requisi√ß√µes HTTP.

Conven√ß√µes:

Nome com sufixo Controller: UserController, OrderController.

Anotados com @RestController ou @Controller.

Exp√µem endpoints com m√©todos anotados (@GetMapping, @PostMapping, etc.).

Interagem com os servi√ßos para processar as requisi√ß√µes.

5. DTOs (Data Transfer Objects)
Fun√ß√£o: Objetos usados para transportar dados entre camadas (especialmente entre controller e client).

Conven√ß√µes:

Nome com sufixo DTO: UserDTO, OrderResponseDTO.

N√£o cont√™m l√≥gica de neg√≥cio.

Podem ter valida√ß√µes com @NotNull, @Size, etc.

6. Utilit√°rios e Helpers
Fun√ß√£o: Cont√™m m√©todos auxiliares e utilit√°rios reutiliz√°veis.

Conven√ß√µes:

Nome com sufixo Utils ou Helper: DateUtils, StringHelper.

M√©todos est√°ticos.

N√£o devem depender de estado interno (idealmente stateless).

7. Configura√ß√µes (Configuration)
Fun√ß√£o: Classes que configuram aspectos da aplica√ß√£o, como beans, seguran√ßa, CORS etc.

Conven√ß√µes:

Nome com sufixo Config: SecurityConfig, CorsConfig.

Anotadas com @Configuration, @Enable..., @Bean, etc.

Boas pr√°ticas gerais:
Cada classe deve ter uma √∫nica responsabilidade.

Os nomes devem ser descritivos e consistentes.

Use pacotes separados para cada camada: model, repository, service, controller, etc.

Classes p√∫blicas devem estar em arquivos com o mesmo nome da classe.

Em Java, a cria√ß√£o de pacotes segue conven√ß√µes que visam manter a organiza√ß√£o, legibilidade e modularidade do c√≥digo. Os nomes de pacotes devem ser escritos sempre em letras min√∫sculas, sem acentos ou caracteres especiais, e normalmente iniciam com o dom√≠nio da organiza√ß√£o escrito de forma invertida, como por exemplo com.empresa.projeto. A estrutura dos pacotes costuma refletir a arquitetura da aplica√ß√£o, sendo comum organiz√°-los por responsabilidade, como model para entidades de dom√≠nio, repository para interfaces de acesso a dados, service para regras de neg√≥cio, controller para endpoints REST, dto para objetos de transfer√™ncia de dados e config para configura√ß√µes gerais. Em sistemas maiores, √© recomend√°vel combinar essa estrutura com uma divis√£o por m√≥dulos de neg√≥cio, agrupando as camadas dentro de pacotes como usuario.service, pedido.controller, entre outros, o que facilita a manuten√ß√£o e favorece a escalabilidade. Al√©m disso, no Spring Boot, a classe principal com a anota√ß√£o @SpringBootApplication costuma ficar no pacote raiz da aplica√ß√£o, permitindo o escaneamento autom√°tico de todos os componentes nas subpastas. √â importante evitar nomes gen√©ricos ou pouco descritivos e manter uma hierarquia de pacotes clara, coerente e alinhada com o dom√≠nio da aplica√ß√£o.

basicamente dentro da src √© s√≥ fazer um monte de pacote com cada pacote repleto de clases que variam de assunto para assunto!

Em Java, a visibilidade de classes, m√©todos e atributos √© controlada por modificadores de acesso, que determinam onde esses elementos podem ser acessados. O modificador public permite o acesso de qualquer lugar, inclusive de outras classes em pacotes diferentes. O modificador protected permite acesso dentro do mesmo pacote e tamb√©m por subclasses, mesmo que estejam em pacotes distintos. O modificador default (tamb√©m chamado de package-private), que ocorre quando nenhum modificador √© especificado, permite o acesso apenas dentro do mesmo pacote, mas n√£o fora dele. J√° o modificador private restringe o acesso exclusivamente √† pr√≥pria classe onde o elemento foi declarado. Usar esses n√≠veis de acesso corretamente √© essencial para garantir o encapsulamento e proteger a integridade dos dados e da l√≥gica da aplica√ß√£o.

Em Java, enums (ou tipos enumerados) s√£o tipos especiais de classe usados para representar um conjunto fixo e constante de valores. Eles s√£o ideais quando se deseja trabalhar com um grupo definido de op√ß√µes, como dias da semana, estados de um pedido ou n√≠veis de prioridade. Ao contr√°rio de constantes tradicionais (public static final), enums oferecem mais seguran√ßa e funcionalidades orientadas a objetos, podendo ter atributos, m√©todos e at√© mesmo comportamentos personalizados.

Um enum √© declarado com a palavra-chave enum e cada valor definido dentro dele √© uma inst√¢ncia constante dessa enumera√ß√£o. Por exemplo, um enum DiaSemana pode conter os valores SEGUNDA, TERCA, QUARTA, etc. Al√©m de simples, os enums em Java podem ser estendidos com campos e construtores, permitindo associar valores ou comportamentos espec√≠ficos a cada constante.

Internamente, enums s√£o classes que herdam da classe java.lang.Enum, n√£o podem ser instanciados diretamente (o construtor √© sempre privado) e s√£o imut√°veis. Eles tamb√©m s√£o √∫teis em estruturas de controle como switch e ajudam a deixar o c√≥digo mais leg√≠vel, seguro e expressivo. Ao utilizar enums, evita-se o uso de "valores m√°gicos" e torna-se o c√≥digo mais autodescritivo e menos propenso a erros.

Records em Java s√£o uma forma concisa de criar classes imut√°veis (um tipo especial de classe) que servem principalmente para armazenar dados. Introduzidos oficialmente no Java 16, eles geram automaticamente construtor, m√©todos equals, hashCode e toString, al√©m de acessores (getters) com o nome do campo. N√£o podem herdar de outras classes, mas podem implementar interfaces. S√£o ideais para representar objetos simples, como DTOs, com menos c√≥digo, em record todo atributo declarado √© privado, lemos seus atributos atrav√©s de m√©todos, √© poss√≠vel ter um constrututor adicional, mas precisamos chamar o construtor default do record para isso, podemos passar valores padr√µes atrav√©s dele ent√£o:
    Se por o construtor default receber um nome e idade, podemos colocar o construtor default como super do construtor adicional e declarar a idade como '1', ent√£o todo objeto criado com o modelo do construtor secund√°rio, isso √©, s√≥ com nome e sem a idade, vai ficar no padr√£o "fulano" 1, "beltrano" 1, e por ai vai! <- SOBRECARGA!

public record Pessoa(String nome, int idade) {}

Nesse exemplo:

nome e idade s√£o campos de inst√¢ncia (n√£o est√°ticos)
S√£o implicitamente private e final
Voc√™ acessa seus valores pelos m√©todos nome() e idade()


Uma classe sealed em Java √© uma classe que pode ser estendida somente por classes espec√≠ficas, definidas explicitamente usando a palavra-chave permits. Isso permite um controle mais rigoroso sobre a heran√ßa, garantindo que a classe n√£o seja estendida por qualquer outra classe, apenas pelas que forem mencionadas.

Caracter√≠sticas:
sealed: Restringe as subclasses permitidas.
permits: Lista as classes que podem estender a classe sealed.
Subclasses podem ser:
final: N√£o podem ser estendidas.
non-sealed: Permitem outras classes para estend√™-las.
sealed: Permite outras classes, mas s√≥ com permiss√µes expl√≠citas.

public sealed class Animal permits Dog, Cat { ... }
public final class Dog extends Animal { ... }
public non-sealed class Cat extends Animal { ... }

Essa abordagem oferece controle e seguran√ßa sobre a heran√ßa e pode ser usada para otimiza√ß√µes de desempenho no compilador.

                Collections

Uma cole√ß√£o (collection) √© uma estrutura de dados que serve para agrupar muitos elementos em uma √∫nica unidade (vari√°vel); estes elementos precisam ser objetos (SEM TIPOS PRIMITIVOS!).
Uma Collection pode ter cole√ß√µes homog√™neas e heterog√™neas, normalmente utilizamos cole√ß√µes homog√™neas de um tipo espec√≠fico.
O n√∫cleo principal das cole√ß√µes √© formado pelas interfaces da figura abaixo; essas interfaces permitem manipular a cole√ß√£o independentemente do n√≠vel de detalhe que elas representam.
Temos quatro grandes tipos de cole√ß√µes: List (lista), Set (conjunto), Queue (fila) e Map (mapa). A partir dessas interfaces, temos muitas subclasses concretas que implementam v√°rias formas diferentes de se trabalhar com cada cole√ß√£o.

Todas as interfaces e classes s√£o encontradas dentro do pacote (package) java.util.
Embora a interface Map n√£o seja filha direta da interface Collection, ela tamb√©m √© considerada uma cole√ß√£o devido √† sua fun√ß√£o.

https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collection.html <- SUMARIO DE M√âTODOS!

https://github.com/cami-la/collections-java-api-2023/tree/master/src/main/java <- RESUM√ÉO PRA CONSULTA POSTERIOR

Generics permitem iterar sobre listas de forma mais simples sem fazer cast!

Maps com generics permitem declarar estritamente o tipo de dado e mais uma vez permitem itera√ß√µes sem cast!

Em Java, Comparable e Comparator s√£o duas interfaces utilizadas para realizar ordena√ß√µes de objetos.

A interface Comparable define a ordem natural de uma classe. Quando uma classe implementa Comparable, ela precisa sobrescrever o m√©todo compareTo(), que define como os objetos dessa classe ser√£o comparados entre si. Isso √© √∫til quando a pr√≥pria classe tem uma forma principal e √∫nica de ser ordenada ‚Äî por exemplo, ordenar produtos pelo pre√ßo.

J√° a interface Comparator √© usada quando queremos definir v√°rias maneiras diferentes de comparar objetos. Ela √© implementada em uma classe separada (ou por uma express√£o lambda), que sobrescreve o m√©todo compare(). Isso √© √∫til quando precisamos ordenar os mesmos objetos de formas diferentes, como por nome, data ou outro crit√©rio espec√≠fico.

A principal diferen√ßa entre elas √© que Comparable define a ordena√ß√£o dentro do pr√≥prio objeto, enquanto Comparator permite definir ordena√ß√µes externas e m√∫ltiplas, oferecendo maior flexibilidade.

                Stream API
√© uma ferramenta que permite processar cole√ß√µes de forma funcional, declarativa e concisa. Ela facilita opera√ß√µes como filtrar, mapear, ordenar, agrupar e reduzir elementos de listas, arrays e outras fontes de dados.

bla bla bla 

DRAW.IO PRA FAZER DIAGRAMAS!!!!!

                SpringBoot

Framework opensource recheado de m√≥dulos para diferentes coisas como web dev, bancos e dados, testes unitarios e etc.

invers√£o de controle √© redirecionar o fluxo de execuc√£o do c√≥digo retirando parcialmente o controle sobre ele e delegando-o para um container, pra minimizar o acoplamento do 

inje√ß√£o de depend√™ncias √© um padr√£o de desenvolvimento com a finalidade de manter o baixo nivel de acoplamento entre modulos de um sistema

bens √© um objeto instanciado (Criado) montado e gerenciado por um container atraves do principio da invers√£o de controle

singleton, o container do spring IOC (inversao de controle) define apenas uma instancia do objeto

prototype, ser√° criado um novo objeto a cada solicita√ß√£o ao container

um bean √© criado para cada requisi√ß√£o http, e exitir√° enquanto a requisi√ß√£o estiver em execu√ß√£o

http session, um bean ser√° criado para a sess√£o de usu√°rio, precisamos acessar a mesma solicita√ß√£o duas vezes para testar os escopos especificos da web

http global, Ou Application Scope cria um bean para o ciclo de vida do contexto da aplica√ß√£o

autowired Uma anota√ß√£o (indica√ß√£o) onde dever√° ocorrer uma inje√ß√£o autom√°tica de depend√™ncia.

byName: √â buscado um m√©todo set que corresponde ao nome do Bean.

byType: √â considerado o tipo da classe para inclus√£o do Bean.

byConstrutor: Usamos o construtor para incluir a depend√™ncia.

Starters s√£o pacotes prontos (depend√™ncias) que o Spring Boot oferece para facilitar a inclus√£o de funcionalidades na sua aplica√ß√£o. Eles agrupam v√°rias bibliotecas comuns em um s√≥ lugar, para que voc√™ n√£o precise configurar tudo manualmente.

Principais Starters do Spring Boot:
Starter	Para que serve
spring-boot-starter-web	Aplica√ß√µes web, APIs REST
spring-boot-starter-data-jpa	Integra√ß√£o com banco de dados usando JPA/Hibernate
spring-boot-starter-security	Seguran√ßa e autentica√ß√£o
spring-boot-starter-test	Testes unit√°rios e de integra√ß√£o
spring-boot-starter-thymeleaf	Templates HTML usando Thymeleaf
spring-boot-starter-actuator	Monitoramento da aplica√ß√£o em tempo real
spring-boot-starter-validation	Valida√ß√µes com Bean Validation (JSR-380, ex: @NotNull, @Email)
data-mongodb: Intera√ß√£o com banco de dados mongoDB

Primeiros passos:

Criando um projeto com initializr (Spring initializr na web)
monta como quiser e bota as depend√™ncias, ele vai baixar um .zip

importando o projeto maven no vscode
tecnicamente ele baixa todas depend√™ncias

Conhecendo a estrutura spring boot
mesmo padr√£o do java, pom.xml tem informa√ß√µes sobre o projeto
src/main/resources/application.proprieties √© onde botamos informa√ß√µes e configura√ß√µes sobre portas de servidores e etc, bancos de dados e por ai vai

Bean e CommandLineRunner


"new" n√£o existe em springboot, √© errado instanciar classes dessa forma, ent√£o nada de 
Pessoa pessoa = new Pessoa("Carlos");

Nosso m√©todo main, ou app.java precisa implementar uma interface chamada "CommandLineRunner" e seus m√©todos, cima dele e logo abaixo das importa√ß√µes devemos ditar que ele ir√° usar componentes, para isso colocamos @Component, note que precisamos fazer o mesmo nas classes que queremos instanciar! 
E abaixo da classe instanciamos a classe dessa forma:
@Autowired
private Pessoa pessoa;
 


Use @Component quando voc√™ quer que o Spring crie e gerencie uma inst√¢ncia de uma classe automaticamente.
Onde usar:
Direto em cima de uma classe que voc√™ criou.
Quando quer que o Spring descubra a classe automaticamente via component scanning.

Exemplo
@Component
public class MeuServico {
    public void executar() {
        System.out.println("Executando servi√ßo...");
    }
}



Use @Bean quando voc√™ quer registrar manualmente um objeto como bean no Spring. √â usado dentro de uma classe anotada com @Configuration.
Onde usar:
Em m√©todos de f√°brica dentro de classes de configura√ß√£o.
Quando precisa criar inst√¢ncias de classes de terceiros (que n√£o t√™m anota√ß√µes Spring).
Quando precisa de l√≥gica personalizada para criar o bean.

Exemplo
@Configuration
public class ConfiguracaoApp {

    @Bean
    public MeuServico meuServico() {
        return new MeuServico();
    }
}


üß† Diferen√ßa pr√°tica
Caracter√≠stica |	@Component |	@Bean
Onde usar |	Em uma classe |	Em um m√©todo
Tipo de controle |	Spring instancia automaticamente |	Voc√™ instancia manualmente
Flexibilidade |	Menos flex√≠vel |	Mais controle na cria√ß√£o do objeto
Ideal para	Suas pr√≥prias classes |	Bibliotecas de terceiros, ou l√≥gica customizada

Quando usar cada um?
Situa√ß√£o |	Use
Classe √© sua e simples	@Component
Classe precisa ser configurada com par√¢metros	@Bean
Classe vem de uma biblioteca externa (sem anota√ß√µes)	@Bean
Voc√™ quer controle sobre como o objeto √© criado	@Bean

√â uma conven√ß√£o criar uma classe "beans" para agrupar os beans!
as vezes precisamos por @Configuration acima na classe mencionada para n√£o ter erro na inje√ß√£o de depend√™ncias

Se tem acesso ao c√≥digo fonte use Components, do contr√°rio, Beans


O que √© escopo (Scope )de um bean?
No Spring, um bean √© um objeto gerenciado pelo container da aplica√ß√£o. O escopo define quantas inst√¢ncias desse objeto ser√£o criadas e como elas ser√£o entregues quando forem requisitadas.


 Singleton (padr√£o do Spring)
O que √©?
√â o escopo padr√£o no Spring. Significa que o Spring cria apenas uma √∫nica inst√¢ncia do bean durante toda a vida da aplica√ß√£o.

Quando usar?
Quando o bean n√£o precisa ser recriado a cada uso, ou seja, pode ser compartilhado por toda a aplica√ß√£o.

Vantagens:
Consome menos mem√≥ria.
Ideal para servi√ßos ou reposit√≥rios que mant√™m estado compartilhado ou s√£o stateless (sem estado).

Exemplo:
@Component
public class MeuServico {
    // ser√° criada apenas uma inst√¢ncia de MeuServico
}


Prototype
O que √©?
Um bean com escopo prototype ser√° criado novamente toda vez que for solicitado ao Spring.

Quando usar?
Quando voc√™ precisa de uma nova inst√¢ncia para cada uso ‚Äî por exemplo, quando o bean tem estado pr√≥prio e n√£o pode ser compartilhado.

Vantagens:
√ötil para objetos com estado tempor√°rio ou dados din√¢micos.
Evita efeitos colaterais entre usu√°rios ou requisi√ß√µes.

Exemplo:
@Scope("prototype")
@Component
public class Pedido {
    // cada vez que for requisitado, um novo Pedido ser√° criado
}


No Spring Boot, o arquivo application.properties serve para guardar configura√ß√µes da aplica√ß√£o, como nomes, URLs ou chaves. A anota√ß√£o @Value √© usada para ler essas configura√ß√µes e injet√°-las dentro do c√≥digo.

Por exemplo, se voc√™ tiver app.nome=MinhaApp no application.properties, pode usar @Value("${app.nome}") em uma classe para acessar esse valor. Isso ajuda a manter o c√≥digo limpo, separado da configura√ß√£o, e facilita a troca de valores conforme o ambiente (dev, prod, etc.).

Se a propriedade n√£o for encontrada, a aplica√ß√£o pode dar erro, mas √© poss√≠vel definir um valor padr√£o assim: @Value("${app.autor:Desconhecido}"). com dois pontos :

@ConfigurationProperties √© uma forma do Spring de carregar v√°rias configura√ß√µes de uma vez em uma classe, ao inv√©s de usar v√°rios @Value. Ela √© usada para mapear um grupo de propriedades do application.properties para atributos de uma classe Java.

Em vez de injetar um por um com @Value, voc√™ define uma classe com atributos e o Spring preenche tudo de forma autom√°tica com base no prefixo configurado.
Por exemplo, se voc√™ tem propriedades como app.nome e app.versao, pode criar uma classe AppProperties, usar @ConfigurationProperties(prefix = "app"), e o Spring liga tudo automaticamente.
√â mais organizado, reutiliz√°vel e limpo, principalmente quando h√° muitas configura√ß√µes relacionadas.


A anota√ß√£o @ConfigurationProperties(prefix = "algum.prefixo") √© usada no Spring para mapear automaticamente propriedades definidas no application.properties (ou application.yml) para os campos de uma classe Java, com base em um prefixo comum.

Exemplo pr√°tico em texto:
Se no application.properties voc√™ tem:
app.nome=MinhaApp
app.versao=1.0


Voc√™ pode criar uma classe assim:
@Configuration
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    private String nome;
    private String versao;
    // getters e setters
}
O Spring vai preencher nome e versao automaticamente com os valores definidos

A classe precisa estar registrada como bean (com @Component ou usando @EnableConfigurationProperties).
Requer m√©todos get e set (ou uso de @Data do Lombok, por exemplo).

Lombok √© uma biblioteca Java que simplifica a escrita de c√≥digo Java, reduzindo c√≥digo boilerplate (c√≥digo repetitivo e comum, como getters e setters) atrav√©s do uso de anota√ß√µes.

No contexto do Spring Boot, os conceitos de ORM e JPA s√£o fundamentais para facilitar o trabalho com bancos de dados de forma orientada a objetos.

ORM, sigla para Object-Relational Mapping (Mapeamento Objeto-Relacional), √© uma t√©cnica que permite mapear objetos do c√≥digo (como classes Java) para tabelas de um banco de dados relacional. Isso significa que, ao inv√©s de escrever comandos SQL diretamente, o desenvolvedor pode manipular dados por meio de objetos Java, enquanto o ORM cuida automaticamente da convers√£o entre esses objetos e os dados no banco.

JPA, ou Java Persistence API, √© uma especifica√ß√£o da linguagem Java que define como os objetos Java devem ser armazenados em bancos de dados relacionais. Ela fornece um conjunto de regras e anota√ß√µes para indicar como as classes devem ser persistidas, mas n√£o realiza essa persist√™ncia diretamente ‚Äî quem faz isso s√£o implementa√ß√µes da JPA, como o Hibernate, que √© a mais usada com Spring Boot.

No Spring Boot, o uso de JPA √© geralmente feito por meio do Spring Data JPA, que integra JPA e Hibernate de forma automatizada. Com ele, √© poss√≠vel mapear uma classe Java para uma tabela do banco com a anota√ß√£o @Entity, definir um identificador com @Id, e criar reposit√≥rios que estendem interfaces como JpaRepository, permitindo acessar e manipular dados com m√©todos prontos, como save, findAll, delete, entre outros.

Al√©m disso, o JPA tamb√©m permite definir os relacionamentos entre entidades, como um-para-muitos ou muitos-para-um, utilizando anota√ß√µes como @OneToMany e @ManyToOne.

Em resumo, o ORM √© a t√©cnica que permite a convers√£o entre objetos Java e tabelas do banco de dados, e a JPA √© a especifica√ß√£o Java que define como essa t√©cnica deve ser aplicada. No Spring Boot, essas ferramentas trabalham juntas para tornar o acesso ao banco de dados mais simples, limpo e orientado a objetos.

A Java Persistence API (JPA) √© uma especifica√ß√£o da plataforma Java que define como os dados de objetos Java devem ser persistidos em bancos de dados relacionais. Ela faz parte da Jakarta EE (anteriormente Java EE) e fornece uma forma padronizada de lidar com a persist√™ncia de dados. JPA √© amplamente utilizada em aplica√ß√µes corporativas e √© a base da persist√™ncia de dados em frameworks como o Spring Boot, que geralmente a utiliza em conjunto com a implementa√ß√£o Hibernate.

Um dos principais recursos da JPA s√£o os mapeamentos entre classes Java e tabelas do banco de dados. Esses mapeamentos s√£o feitos por meio de anota√ß√µes nas classes. Por exemplo, a anota√ß√£o @Entity indica que a classe √© uma entidade persistente e deve ser mapeada para uma tabela. A anota√ß√£o @Table pode ser usada para especificar o nome da tabela correspondente. Cada atributo da classe representa uma coluna da tabela, e pode ser configurado com anota√ß√µes como @Column, @Id (para a chave prim√°ria), @GeneratedValue (para gera√ß√£o autom√°tica de IDs), entre outras.

Al√©m disso, JPA suporta relacionamentos entre entidades, como um-para-um (@OneToOne), um-para-muitos (@OneToMany), muitos-para-um (@ManyToOne) e muitos-para-muitos (@ManyToMany). Esses relacionamentos representam liga√ß√µes entre tabelas e s√£o essenciais para modelar estruturas de dados complexas no banco relacional.

No cora√ß√£o da JPA est√° o EntityManager, que √© a interface principal para realizar opera√ß√µes de persist√™ncia. Ele √© respons√°vel por gerenciar o ciclo de vida das entidades, incluindo opera√ß√µes como salvar, atualizar, remover e buscar objetos no banco de dados. Por exemplo, para persistir um objeto, utiliza-se o m√©todo persist, e para buscar um objeto pelo seu ID, usa-se o m√©todo find. O EntityManager tamb√©m fornece suporte para consultas com JPQL (Java Persistence Query Language), que √© uma linguagem de consulta orientada a objetos, similar ao SQL, mas operando sobre entidades ao inv√©s de tabelas diretamente.

O EntityManager geralmente √© injetado via anota√ß√£o @PersistenceContext, e seu ciclo de vida √© gerenciado pelo container (no caso de aplica√ß√µes Java EE) ou pelo Spring, quando usado com Spring Boot. Um exemplo b√°sico de uso seria:

@PersistenceContext
private EntityManager entityManager;


Com ele, pode-se realizar opera√ß√µes como:

entityManager.persist(cliente);
Cliente encontrado = entityManager.find(Cliente.class, 1L);
entityManager.remove(encontrado);


Em resumo, a JPA padroniza o mapeamento objeto-relacional em Java, permitindo que desenvolvedores trabalhem com dados de maneira orientada a objetos. Seus mapeamentos facilitam a transforma√ß√£o de classes em tabelas e seus campos em colunas, enquanto o EntityManager √© o componente central para interagir com o banco de dados, controlando o ciclo de vida das entidades e fornecendo uma interface poderosa para opera√ß√µes de persist√™ncia.

Spring Data JPA √© um projeto do ecossistema Spring que facilita o uso da Java Persistence API (JPA) em aplica√ß√µes Spring, especialmente com o Spring Boot. Ele abstrai grande parte da complexidade do acesso a dados, fornecendo uma forma simples, poderosa e declarativa de interagir com bancos de dados relacionais.

Na pr√°tica, o Spring Data JPA permite que voc√™ trabalhe com reposit√≥rios de dados (interfaces) sem precisar implementar manualmente consultas ou l√≥gica de persist√™ncia. Ele se integra com implementa√ß√µes de JPA como o Hibernate, que √© a mais comum, e gerencia automaticamente o EntityManager, sess√µes e transa√ß√µes.

O principal recurso do Spring Data JPA √© a cria√ß√£o autom√°tica de m√©todos de acesso a dados com base na nomenclatura dos m√©todos. Por exemplo, se voc√™ tiver uma entidade chamada Cliente, basta criar uma interface como ClienteRepository estendendo JpaRepository, e poder√° utilizar m√©todos prontos como findAll(), findById(), save(), delete(), entre outros, sem escrever nenhuma linha de SQL.

Al√©m dos m√©todos prontos, voc√™ pode criar m√©todos personalizados com base em nomes descritivos, como findByNome(String nome) ou findByEmailAndStatus(String email, String status). O Spring interpreta esses nomes e gera automaticamente as consultas correspondentes.

O Spring Data JPA tamb√©m permite escrever consultas mais complexas usando JPQL, SQL nativo, ou a API de Specification, que fornece crit√©rios din√¢micos de consulta. Essas consultas podem ser anotadas com @Query nas interfaces de reposit√≥rio.

Outra vantagem √© o suporte a pagina√ß√£o e ordena√ß√£o, que pode ser feito facilmente usando os tipos Pageable e Sort, permitindo que se implementem APIs REST com controle total sobre o volume e a ordem dos dados retornados.

Por fim, o Spring Data JPA se integra muito bem ao restante do ecossistema Spring, como Spring Security, Spring Web e Spring Boot, simplificando drasticamente o desenvolvimento de aplica√ß√µes robustas e escal√°veis, ELE √â UMA DEPEND√™NCIA QUE VOC√ä COLOCA NO Spring initializr, temos que por tamb√©m as depend√™ncias do banco de dados que vamos utilizar

Para configurar o PostgreSQL como banco de dados em um projeto Spring Boot com Spring Data JPA, √© necess√°rio adicionar a depend√™ncia do driver do PostgreSQL e definir corretamente as propriedades de conex√£o no arquivo de configura√ß√£o da aplica√ß√£o (application.properties ou application.yml).

No Maven, a depend√™ncia do PostgreSQL deve ser adicionada ao arquivo pom.xml da seguinte forma:
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>

Caso esteja usando Gradle, a linha correspondente no build.gradle seria:
runtimeOnly 'org.postgresql:postgresql'

Depois disso, o pr√≥ximo passo √© configurar a conex√£o no arquivo application.properties. As propriedades b√°sicas incluem:
spring.datasource.url=jdbc:postgresql://localhost:5432/nomedobanco
spring.datasource.username=seu_usuario
spring.datasource.password=sua_senha
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.hibernate.ddl-auto=update
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.show-sql=true


Essas configura√ß√µes definem a URL de conex√£o JDBC com o PostgreSQL (onde localhost √© o host, 5432 √© a porta padr√£o e nomedobanco √© o nome do seu banco de dados), al√©m do nome de usu√°rio e senha. O hibernate.ddl-auto=update faz com que o Hibernate atualize automaticamente o schema do banco conforme as entidades, √∫til durante o desenvolvimento. A propriedade show-sql=true exibe as queries SQL no console, o que ajuda na depura√ß√£o.

Al√©m disso, √© importante garantir que o servi√ßo do PostgreSQL esteja rodando e que o banco e as credenciais especificadas existam. Para projetos maiores ou ambientes de produ√ß√£o, outras propriedades como connection pool, caching, e logging podem ser ajustadas.

O JpaRepository √© uma interface do Spring Data JPA que fornece um conjunto completo de m√©todos prontos para realizar opera√ß√µes de persist√™ncia em entidades JPA. Ela faz parte da infraestrutura que facilita a integra√ß√£o entre o Spring Boot e a JPA, evitando a necessidade de escrever implementa√ß√µes manuais de acesso a dados.

Ao estender a interface JpaRepository, o desenvolvedor herda m√©todos para opera√ß√µes comuns como salvar (save), buscar por ID (findById), buscar todos (findAll), deletar (delete), entre outros. Isso permite focar na l√≥gica de neg√≥cio, sem a necessidade de escrever c√≥digo repetitivo de acesso a banco.

Por exemplo, em vez de criar uma implementa√ß√£o para um reposit√≥rio de clientes, basta criar uma interface como ClienteRepository estendendo JpaRepository<Cliente, Long>, onde Cliente √© a entidade e Long √© o tipo do ID. Com isso, o Spring gera automaticamente a implementa√ß√£o dos m√©todos de CRUD.

Al√©m dos m√©todos herdados, o JpaRepository permite definir m√©todos personalizados com base na nomenclatura. Por exemplo, um m√©todo findByNome(String nome) √© interpretado automaticamente pelo Spring como uma consulta para buscar clientes pelo campo nome.

O JpaRepository tamb√©m oferece suporte a pagina√ß√£o, ordena√ß√£o, proje√ß√µes, e consultas personalizadas usando anota√ß√µes como @Query (com JPQL ou SQL nativo).

Por estar integrado com o Spring Boot, o uso de JpaRepository tamb√©m se beneficia da inje√ß√£o de depend√™ncia e da configura√ß√£o autom√°tica de componentes, tornando o desenvolvimento r√°pido, organizado e aderente √†s boas pr√°ticas do Spring.


REST e RESTful:

REST (Representational State Transfer) √© um estilo de arquitetura de software para sistemas distribu√≠dos, geralmente usado na constru√ß√£o de APIs. Ele se baseia em um conjunto de restri√ß√µes, como a utiliza√ß√£o de HTTP para comunica√ß√£o e a utiliza√ß√£o de m√©todos como GET, POST, PUT e DELETE. O REST enfatiza a simplicidade e a escalabilidade.

RESTful refere-se √† implementa√ß√£o de uma API que segue as restri√ß√µes e princ√≠pios do REST. Isso significa que a API deve ser baseada em recursos (URLs) e deve utilizar os m√©todos HTTP de forma adequada.

Controllers:

Controllers (ou controladores) s√£o componentes essenciais na arquitetura de software, particularmente no padr√£o MVC (Model-View-Controller). Em APIs RESTful, os controladores s√£o respons√°veis por manipular as requisi√ß√µes HTTP, interagir com os modelos de dados (como banco de dados) e retornar as respostas apropriadas ao cliente. Os controladores mapeiam as rotas de requisi√ß√£o para as fun√ß√µes espec√≠ficas que devem ser executadas.

Swagger:

Swagger √© uma ferramenta que permite documentar, testar e visualizar APIs de forma interativa. Ela gera documenta√ß√£o interativa de uma API RESTful e permite que os desenvolvedores e usu√°rios interajam diretamente com a API atrav√©s de uma interface gr√°fica. Com o Swagger, √© poss√≠vel ver as opera√ß√µes dispon√≠veis, os par√¢metros necess√°rios e at√© testar as chamadas da API de maneira f√°cil.

Exception Handler:

Exception Handler (ou manipulador de exce√ß√µes) √© um mecanismo utilizado em APIs para tratar erros de maneira adequada. Ele captura exce√ß√µes (erros) que ocorrem durante o processamento das requisi√ß√µes e fornece respostas apropriadas, como mensagens de erro ou c√≥digos de status HTTP (por exemplo, 404 para "n√£o encontrado" ou 500 para "erro interno do servidor"). O tratamento adequado de exce√ß√µes √© fundamental para garantir que a API seja robusta e f√°cil de usar, fornecendo informa√ß√µes claras sobre o que deu errado.

Esses s√£o conceitos fundamentais no desenvolvimento de APIs modernas, especialmente quando se busca construir sistemas escal√°veis, robustos e bem documentados.


                Bancos de Dados Relacionais!

DBMS √© o software usado para acessar, manipular e monitorar um sistema de banco de dados! ele √© diferente do proprio DB √© mais como uma interface gr√°fica e cada DB tem o seu pr√≥prio

MySQL express ou pra dev s√£o iguais, mas use a vers√£o express! pro Mysql precisa de SSMS tamb√©m (as vezes instalado diretamente do setup do Mysql) ou atrav√©s do site da microsoft

MER ‚Äì Modelo Entidade-Relacionamento
MER (Modelo Entidade-Relacionamento) √© uma abordagem conceitual de modelagem de dados, proposta por Peter Chen em 1976. Ele serve para representar de forma abstrata e sem preocupa√ß√£o com tecnologia como os dados se relacionam entre si no dom√≠nio do problema.

Principais componentes do MER:
Entidade: Representa um "objeto" do mundo real (ex: Cliente, Produto).

Representado como ret√¢ngulo.

Atributo: Propriedade ou caracter√≠stica da entidade (ex: nome, CPF).

Representado como elipse.

Relacionamento: Mostra como as entidades est√£o conectadas (ex: "compra", "possui").

Representado como losango.

Cardinalidade: Indica a quantidade de ocorr√™ncias entre as entidades (1:1, 1:N, N:N).

Exemplo: Um Cliente compra um ou v√°rios Produtos.

DER ‚Äì Diagrama Entidade-Relacionamento
DER (Diagrama Entidade-Relacionamento) √© a representa√ß√£o gr√°fica do MER. Ou seja, √© o desenho que mostra visualmente as entidades, relacionamentos, atributos e cardinalidades.

√â usado para documentar e comunicar a estrutura dos dados entre analistas, desenvolvedores e stakeholders.

Serve como base para transformar o modelo conceitual em modelo l√≥gico e f√≠sico, que s√£o implementados no banco de dados.

Diferen√ßa entre MER e DER
Termo |	Significado	Papel
MER	Modelo Entidade-Relacionamento	√â o modelo conceitual (ideia, conceito)
DER	Diagrama Entidade-Relacionamento	√â a representa√ß√£o gr√°fica (o desenho) do MER

site Creately.com para criar os diagramas!
app.quickdatabasediagrams.com para fazer diagramas com base no c√≥digo sql!

banco de dados na nuvem que ser√° usado nas aulas da dio -> clients.cloudclusters.io <- n√£o √© gratuito (apenas 7 dias)
https://accounts.cloudclusters.io/login/?next=https%3A%2F%2Fclients.cloudclusters.io%2F

Comente seus dbs!

Tabela de exemplo da dio

CREATE TABLE usuarios(
    id INT,
    nome VARCHAR(255) NOT NULL COMMENT 'Nome do usuario',
    email VARCHAR(100) NOT NULL UNIQUE COMMENT 'Email do usuario',
    endereco VARCHAR(50) NOT NULL COMMENT 'Endere√ßo do usuario',
    data_nascimento DATE NOT NULL COMMENT 'Data de nascimento do usuario');

CREATE TABLE viagens.destinos <-// db viagens tabela destinos = viagens.destinos//> (
    id INT,
    nome VARCHAR(255) NOT NULL UNIQUE COMMENT 'Nome do destino',
    descricao VARCHAR(255) NOT NULL COMMENT 'Descri√ß√£o do destino'
);

CREATE TABLE viagens.reservas (
    id INT COMMENT 'Identificador √∫nico da reserva',
    id_usuario INT COMMENT 'Refer√™ncia ao ID do usu√°rio que fez a reserva',
    id_destino INT COMMENT 'Refer√™ncia ao ID do destino da reserva',
    data DATE COMMENT 'Data da reserva',
    status VARCHAR(255) DEFAULT 'pendente' COMMENT 'Status da reserva (confirmada, pendente, cancelada, etc.)'
);

macete pra copiar dados
INSERT INTO usuarios_nova (id, nome, email, endereco, data_nascimento)
SELECT id, nome, email, endereco, data_nascimento
FROM usuarios;

A normaliza√ß√£o de dados √© o processo de organizar os dados em um banco de dados para:

Evitar redund√¢ncias
Garantir integridade dos dados
Facilitar a manuten√ß√£o
Ela √© feita em etapas chamadas formas normais (FN). Cada etapa elimina certos problemas. Aqui vai um resumo das principais:

üîπ 1¬™ Forma Normal (1FN)
Regras: Eliminar atributos multivalorados (nada de listas ou tabelas dentro de colunas).

Objetivo: Cada campo deve conter um √∫nico valor at√¥mico.
‚úÖ Tabela com colunas bem definidas e dados simples.

üîπ 2¬™ Forma Normal (2FN)
Regras: Estar na 1FN e eliminar depend√™ncias parciais (colunas que dependem s√≥ de parte da chave prim√°ria composta).

Objetivo: Todos os atributos devem depender da chave prim√°ria inteira.
‚úÖ Evita repeti√ß√£o de informa√ß√µes parciais.

üîπ 3¬™ Forma Normal (3FN)
Regras: Estar na 2FN e eliminar depend√™ncias transitivas (atributos que dependem de outro atributo que n√£o √© chave).

Objetivo: Todos os atributos devem depender somente da chave prim√°ria.
‚úÖ Remove colunas que n√£o s√£o essenciais para identificar uma linha.

Exemplo r√°pido:
Uma tabela de pedidos com:

cliente_nome, cliente_email, produto_nome, quantidade

Problemas:

Dados do cliente se repetem em cada pedido.

Nome do produto tamb√©m.

Solu√ß√£o com normaliza√ß√£o:

Tabela clientes

Tabela produtos

Tabela pedidos com refer√™ncias (chaves estrangeiras)


                Bancos de dados n√£o relacionais

As diferen√ßas entre bancos de dados relacionais (SQL) e n√£o relacionais (NoSQL) est√£o ligadas √† forma como os dados s√£o armazenados, estruturados e consultados. Abaixo est√° um resumo claro e direto:

üìò Bancos de Dados Relacionais (SQL)
‚úÖ Estrutura fixa (tabelas) com linhas e colunas

‚úÖ Esquema r√≠gido: exige defini√ß√£o pr√©via dos campos (tipos, restri√ß√µes, etc.)

‚úÖ Usa SQL (Structured Query Language) para consultas

‚úÖ Ideal para dados altamente estruturados e com relacionamentos complexos

‚úÖ Transa√ß√µes ACID (Atomicidade, Consist√™ncia, Isolamento, Durabilidade)

Exemplos: MySQL, PostgreSQL, Oracle, SQL Server

üìô Bancos de Dados N√£o Relacionais (NoSQL)
‚úÖ Estrutura flex√≠vel, podendo usar:

Documentos (JSON, BSON) ‚Äì ex: MongoDB

Chave-valor ‚Äì ex: Redis

Grafos ‚Äì ex: Neo4j

Colunar ‚Äì ex: Cassandra

‚úÖ Sem esquema fixo (schema-less) ‚Äî cada registro pode ter campos diferentes

‚úÖ Projetado para alta escalabilidade e grandes volumes de dados (Big Data)

‚úÖ Prioriza disponibilidade e performance sobre transa√ß√µes r√≠gidas

‚úÖ Melhor para dados semiestruturados ou desestruturados

Exemplos: MongoDB, Cassandra, Redis, CouchDB, Neo4j

| Caracter√≠stica           | SQL (Relacional)         | NoSQL (N√£o Relacional)                       |
| ------------------------ | ------------------------ | -------------------------------------------- |
| Estrutura                | Tabelas (linhas/colunas) | Documentos, grafos, etc.                     |
| Esquema                  | Fixo                     | Flex√≠vel ou inexistente                      |
| Linguagem de consulta    | SQL                      | Depende do banco (ex: MongoDB usa JSON-like) |
| Escalabilidade           | Vertical (mais hardware) | Horizontal (mais servidores)                 |
| Relacionamentos          | Fortemente suportados    | Limitados ou inexistentes                    |
| Performance com Big Data | Limitada                 | Otimizada                                    |
| Transa√ß√µes ACID          | Sim                      | Parcial ou eventual                          |


‚úÖ O que √© um Banco de Dados NoSQL?
NoSQL significa "Not Only SQL" e representa uma categoria de bancos de dados que n√£o seguem o modelo relacional tradicional. Eles foram criados para lidar com grandes volumes de dados, alta escalabilidade e estrutura de dados flex√≠vel, especialmente em aplica√ß√µes modernas como redes sociais, sistemas de recomenda√ß√£o, e an√°lise de big data.

üß© Principais caracter√≠sticas do NoSQL:
Sem esquema fixo (schema-less): os dados podem ter formatos variados, como JSON, sem precisar de uma estrutura pr√©-definida.

Alta escalabilidade: facilitam o crescimento horizontal (adicionar mais servidores).

Alto desempenho: √≥timos para leitura e escrita r√°pida de grandes quantidades de dados.

Flexibilidade: √≥timo para dados n√£o estruturados ou semiestruturados (ex: logs, posts, sensores).

Eventual consistency: prioriza disponibilidade e desempenho, podendo abrir m√£o da consist√™ncia imediata (em oposi√ß√£o ao modelo ACID dos bancos relacionais).

üìö Tipos de Bancos NoSQL
Baseado em Documentos

Armazenam dados em formato tipo JSON/BSON.

Exemplo: MongoDB, CouchDB

Ideal para: Aplica√ß√µes web, APIs, CMS

Chave-Valor

Dados armazenados como pares chave : valor.

Exemplo: Redis, Riak

Ideal para: Caches, sess√µes, configura√ß√£o

Colunar

Armazenam dados por colunas, otimizando leitura de grandes volumes.

Exemplo: Cassandra, HBase

Ideal para: Big Data, data warehouses

Grafos

Dados armazenados como n√≥s e arestas, representando rela√ß√µes complexas.

Exemplo: Neo4j, ArangoDB

Ideal para: Redes sociais, sistemas de recomenda√ß√£o, mapas de rotas

üìå Quando usar NoSQL?
Use NoSQL quando:

Os dados mudam frequentemente ou t√™m estrutura variada.

√â preciso escalar para milh√µes de usu√°rios ou registros.

H√° necessidade de alta performance em leitura/escrita.

N√£o √© essencial manter consist√™ncia r√≠gida em transa√ß√µes.


üß† O que s√£o Grafos?
Grafos s√£o uma estrutura de dados formada por:

N√≥dulos (n√≥s): representam entidades (ex: pessoas, cidades, produtos)

Arestas (relacionamentos): representam as liga√ß√µes entre os n√≥s (ex: amizade, dist√¢ncia, compra)

Cada n√≥ e aresta pode ter propriedades (atributos).
Esse modelo √© ideal para representar rela√ß√µes complexas e interconectadas.

üìå Exemplo de grafo:
Imagine um grafo com pessoas e amizades:
(Ana) ----[amiga]----> (Jo√£o)
  |                       |
[amiga]                [amigo]
  |                       |
(Rafa) <---[amigo]---- (Carlos)
Esse tipo de estrutura √© ideal para perguntas como:

‚ÄúQuem s√£o os amigos em comum entre Ana e Jo√£o?‚Äù
‚ÄúQual o caminho mais curto entre duas pessoas?‚Äù
‚ÄúQuem influencia quem em uma rede social?‚Äù

                üß∞ O que √© o Neo4j?
Neo4j √© o banco de dados de grafos mais popular. Ele armazena dados como n√≥s e relacionamentos diretamente, diferente dos bancos relacionais ou NoSQL documentais.

üîπ Caracter√≠sticas do Neo4j:
Modelo de grafo nativo

Consultas com Cypher, uma linguagem pr√≥pria parecida com SQL

Alta performance em consultas complexas de relacionamentos

Usado em redes sociais, sistemas de recomenda√ß√£o, fraudes, rotas, etc.

Exemplo de consulta em Cypher (Neo4j):
MATCH (a:Pessoa {nome: "Ana"})-[:AMIGO]->(amigo)
RETURN amigo.nome
Interpreta√ß√£o: Retorna os nomes dos amigos de Ana.
üß© Exemplo de modelagem:
Entidades (n√≥s):
(:Pessoa {nome: "Ana"})

(:Filme {titulo: "Matrix"})

Relacionamento (aresta):
(Ana)-[:ASSISTIU]->(Matrix)

‚úÖ Quando usar grafos/Neo4j?
Use quando:

H√° muitos relacionamentos entre os dados

Precisa de consultas r√°pidas em redes (ex: amigos de amigos, rotas, conex√µes)

Sistemas como: redes sociais, log√≠stica, IA, recomenda√ß√£o

Vamos usar o sandboxneo4j.com para aprender grafos!
https://sandbox.neo4j.com

Comando de cria√ß√£o de n√≥s e relacionamentos
CREATE
  (c1:Client {name: "Fulano", hobbies: ["Ca√ßa patos"]}),
  (c2:Client {name: "Beltrano", hobbies: ["Pescaria", "Futebol"]}),
  (c3:Client {name: "Ciclano", hobbies: ["Leitura", "Xadrez"]}),
  (c1)-[:AMIGO_DE]->(c2),
  (c2)-[:AMIGO_DE]->(c3),
  (c3)-[:AMIGO_DE]->(c1)


Note que n√£o h√° estrutura fixa para cria√ß√£o dos Clients que definimos!


comando de retorno de todos (get *)
MATCH (todos) RETURN todos;


 1. CRIAR N√ìS (ENTIDADES)
CREATE (:Pessoa {nome: "Ana", idade: 30})
CREATE (:Filme {titulo: "Matrix", ano: 1999})

üîÅ 2. CRIAR RELACIONAMENTOS
MATCH (p:Pessoa {nome: "Ana"}), (f:Filme {titulo: "Matrix"})
CREATE (p)-[:ASSISTIU {avaliacao: 5}]->(f)
:ASSISTIU √© o tipo do relacionamento

{avaliacao: 5} s√£o propriedades do relacionamento

üîç 3. CONSULTAR RELACIONAMENTOS
MATCH (p:Pessoa)-[:ASSISTIU]->(f:Filme)
RETURN p.nome, f.titulo

üîÅ 4. CONSULTAR COM FILTROS
MATCH (p:Pessoa)-[r:ASSISTIU]->(f:Filme)
WHERE r.avaliacao >= 4
RETURN p.nome, f.titulo, r.avaliacao

üïµÔ∏è‚Äç‚ôÇÔ∏è 5. ENCONTRAR CAMINHOS
MATCH (a:Pessoa {nome: "Ana"})-[:AMIGO*1..2]-(amigo)
RETURN amigo
*1..2 ‚Üí encontra amigos em at√© 2 n√≠veis de conex√£o

‚úèÔ∏è 6. EDITAR (UPDATE) N√ìS E RELA√á√ïES
MATCH (p:Pessoa {nome: "Ana"})
SET p.idade = 31
MATCH (:Pessoa {nome: "Ana"})-[r:ASSISTIU]->(:Filme {titulo: "Matrix"})
SET r.avaliacao = 4

üßΩ 7. REMOVER DADOS
Deletar um relacionamento:
MATCH (:Pessoa {nome: "Ana"})-[r:ASSISTIU]->(:Filme {titulo: "Matrix"})
DELETE r
Deletar um n√≥ (sem relacionamentos):
MATCH (p:Pessoa {nome: "Ana"})
DELETE p
For√ßar deletar um n√≥ com relacionamentos:
MATCH (p:Pessoa {nome: "Ana"})
DETACH DELETE p

üßÆ 8. CONTAR E AGRUPAR
MATCH (:Pessoa)-[:ASSISTIU]->(f:Filme)
RETURN f.titulo, COUNT(*) AS total_assistido
üåê 9. IMPORTANTE: TIPAGEM
:Label ‚Üí define o tipo do n√≥ (:Pessoa, :Filme)

[RELACIONAMENTO] ‚Üí define a rela√ß√£o entre dois n√≥s

Propriedades ‚Üí chave-valor em { }

üîÑ 10. CRIAR TUDO DE UMA VEZ
CREATE (a:Pessoa {nome: "Carlos"})-[:AMIGO]->(b:Pessoa {nome: "Bruno"})


                O que √© o Apache Cassandra?
Cassandra √© um banco de dados NoSQL distribu√≠do e orientado a colunas, criado pelo Facebook e depois aberto para a comunidade Apache.

Ele √© feito para escalar horizontalmente e lidar com grandes volumes de dados com alta disponibilidade, mesmo com falhas de n√≥s no cluster.

üîë Principais caracter√≠sticas do Cassandra:
üì¶ Modelo colunar (como se fossem tabelas com colunas din√¢micas)
üß± Alta escalabilidade horizontal (basta adicionar n√≥s)
‚öôÔ∏è Alta disponibilidade e toler√¢ncia a falhas
üõ°Ô∏è Sem ponto √∫nico de falha
üßÆ Baseado no modelo de chave prim√°ria + colunas
üöÄ Ideal para aplica√ß√µes com escrita intensa e grandes volumes de dados

üìö Terminologia b√°sica
| Conceito          | Explica√ß√£o                                  |
| ----------------- | ------------------------------------------- |
| **Cluster**       | Conjunto de n√≥s Cassandra                   |
| **Node**          | Um servidor do cluster                      |
| **Keyspace**      | Equivale a um banco de dados                |
| **Table**         | Conjunto de registros (linhas e colunas)    |
| **Row**           | Registro com chave prim√°ria                 |
| **Partition Key** | Chave usada para distribuir dados entre n√≥s |
| **CQL**           | Cassandra Query Language (semelhante a SQL) |


 TUTORIALZ√ÉO: comandos em CQL (Cassandra Query Language)
‚úÖ 1. Criar um Keyspace
CREATE KEYSPACE minha_app
WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};
SimpleStrategy: uso local (desenvolvimento)

replication_factor: n√∫mero de c√≥pias dos dados

‚úÖ 2. Usar o Keyspace
USE minha_app;

‚úÖ 3. Criar uma Tabela
CREATE TABLE usuarios (
  id UUID PRIMARY KEY,
  nome TEXT,
  email TEXT,
  idade INT
);
PRIMARY KEY: obrigat√≥rio; define a chave de parti√ß√£o e ordena√ß√£o.

‚úÖ 4. Inserir dados
INSERT INTO usuarios (id, nome, email, idade)
VALUES (uuid(), 'Ana', 'ana@email.com', 25);

‚úÖ 5. Buscar dados
SELECT * FROM usuarios;

‚úÖ 6. Buscar por chave prim√°ria
SELECT * FROM usuarios WHERE id = 9f4c0b8b-40d6-4a3d-81a9-12ef3894f15a;
‚ö†Ô∏è Cassandra s√≥ permite WHERE com a chave prim√°ria ou √≠ndices criados.

‚úÖ 7. Atualizar dados
UPDATE usuarios SET idade = 26 WHERE id = 9f4c0b8b-40d6-4a3d-81a9-12ef3894f15a;

‚úÖ 8. Deletar dados
DELETE FROM usuarios WHERE id = 9f4c0b8b-40d6-4a3d-81a9-12ef3894f15a;

‚úÖ 9. Criar √≠ndice secund√°rio (para filtrar por outro campo)
CREATE INDEX ON usuarios (email);

‚úÖ 10. Consultar com √≠ndice secund√°rio
SELECT * FROM usuarios WHERE email = 'ana@email.com';

üß† Quando usar Cassandra?
Use Cassandra quando voc√™ precisa de:
Grande volume de dados distribu√≠dos
Escritas r√°pidas e escal√°veis
Alta disponibilidade mesmo com falhas
Eventual consistency (consist√™ncia eventual)
Baixa lat√™ncia

üöÄ Extras:
üì• Ferramenta para usar CQL:
CLI: cqlsh (instalado com Cassandra)
GUI: DataStax Studio


                üß† O que √© o Redis?
Redis (REmote DIctionary Server) √© um banco de dados NoSQL em mem√≥ria, extremamente r√°pido, usado como:

Banco de dados chave-valor
Cache
Fila de mensagens (Pub/Sub)
Armazenamento tempor√°rio

üîë Caracter√≠sticas principais:
| Caracter√≠stica               | Explica√ß√£o                                     |
| ---------------------------- | ---------------------------------------------- |
| üî• **Ultra r√°pido**          | Armazenado em mem√≥ria RAM                      |
| ‚öôÔ∏è **Estrutura chave-valor** | Trabalha com strings, listas, hashes, sets etc |
| üß± **Simples e leve**        | √ìtimo para cache, contadores, sess√µes etc      |
| üîÅ **Persist√™ncia opcional** | Pode salvar dados em disco                     |
| üì¶ **Suporta TTL**           | Expira√ß√£o de chaves (ideal pra cache)          |

Instala√ß√£o (via Docker ‚Äî mais f√°cil)
docker run --name redis -p 6379:6379 -d redis
Depois disso, voc√™ pode acessar com:

docker exec -it redis redis-cli
üìö REDIS TUTORIALZ√ÉO ‚Äì COMANDOS ESSENCIAIS

‚úÖ 1. Setar e obter valores (strings)
SET nome "Fulano"
GET nome

‚è±Ô∏è 2. Setar com tempo de expira√ß√£o
SET email "fulano@email.com" EX 60  # expira em 60 segundos

‚úÖ 3. Trabalhar com contadores
INCR visitas
INCRBY visitas 10
DECR visitas
GET visitas

‚úÖ 4. Listas (tipo pilha/fila)
LPUSH tarefas "Lavar roupa"
LPUSH tarefas "Estudar Redis"
RPUSH tarefas "Jogar bola"

LRANGE tarefas 0 -1  # Mostra tudo na lista
LPOP tarefas         # Remove do in√≠cio
RPOP tarefas         # Remove do fim

‚úÖ 5. Hashes (semelhante a objetos ou dicion√°rios)
HSET usuario:1 nome "Ana" email "ana@email.com"
HGETALL usuario:1
HGET usuario:1 nome

‚úÖ 6. Sets (conjuntos, sem repeti√ß√£o)
SADD amigos "Jo√£o" "Maria" "Carlos"
SMEMBERS amigos
SISMEMBER amigos "Jo√£o"
SREM amigos "Carlos"

‚úÖ 7. Sorted Sets (com pontua√ß√£o)
ZADD ranking 100 "Jo√£o"
ZADD ranking 200 "Ana"
ZADD ranking 150 "Carlos"

ZRANGE ranking 0 -1 WITHSCORES   # ordem crescente
ZREVRANGE ranking 0 -1 WITHSCORES # ordem decrescente

‚úÖ 8. Verificar exist√™ncia e deletar chave
EXISTS nome
DEL nome

‚úÖ 9. Tempo de vida (TTL)
TTL email
EXPIRE email 120

‚úÖ 10. Pub/Sub (mensageria)
Terminal 1 ‚Äì assinando canal:

SUBSCRIBE noticias
Terminal 2 ‚Äì publicando:

PUBLISH noticias "Nova not√≠cia publicada!"
üî• Exemplo de modelagem Redis para usu√°rios
# Criar usu√°rio com ID 1
HSET user:1 name "Bruno" email "bruno@ex.com"
SADD user:1:hobbies "Futebol" "Filmes"

‚úÖ Quando usar Redis?
Cache de p√°ginas, sess√µes ou tokens
Contadores em tempo real (views, likes)
Armazenar filas ou tarefas
Ranking de jogadores, pontua√ß√µes
Sistema de chat ou notifica√ß√£o com Pub/Sub


                üß† O que √© o MongoDB?
MongoDB √© um banco de dados NoSQL orientado a documentos, que armazena dados no formato JSON (na pr√°tica, BSON).

Em vez de tabelas e linhas como bancos relacionais, o MongoDB usa:
Cole√ß√µes (equivalente a tabelas)
Documentos (equivalente a registros)

üîë Principais caracter√≠sticas:
| Recurso                         | Explica√ß√£o                                      |
| ------------------------------- | ----------------------------------------------- |
| üìÑ **Documentos JSON-like**     | Estrutura flex√≠vel, sem esquema fixo            |
| üöÄ **Escal√°vel e perform√°tico** | Escalabilidade horizontal com sharding          |
| üìÇ **Cole√ß√µes**                 | Conjuntos de documentos                         |
| üîé **Consultas poderosas**      | Com filtros, proje√ß√µes e agrega√ß√µes             |
| üìå **√çndices**                  | Suporte a √≠ndices, texto completo, geoespaciais |
| üîê **Alta disponibilidade**     | Suporte a replica√ß√£o (replica sets)             |

üõ†Ô∏è Como usar o MongoDB
üì¶ Instalar (via Docker)
docker run -d -p 27017:27017 --name mongo mongo
Acesse com MongoDB Compass (GUI) ou pela CLI:

docker exec -it mongo mongosh
üìö TUTORIALZ√ÉO ‚Äì Comandos MongoDB (via mongosh)
‚úÖ 1. Criar banco e cole√ß√£o
use minha_app   // cria ou seleciona o banco
db.createCollection("usuarios")  // opcional; √© criado automaticamente ao inserir

‚úÖ 2. Inserir documentos
db.usuarios.insertOne({
  nome: "Fulano",
  email: "fulano@email.com",
  idade: 30,
  hobbies: ["ler", "correr"]
})
db.usuarios.insertMany([
  { nome: "Beltrano", idade: 25 },
  { nome: "Ciclano", idade: 40 }
])

‚úÖ 3. Buscar documentos
db.usuarios.find()               // todos
db.usuarios.find({ idade: 30 })  // filtrado
db.usuarios.findOne({ nome: "Fulano" })

‚úÖ 4. Atualizar documentos
db.usuarios.updateOne(
  { nome: "Fulano" },
  { $set: { idade: 31 } }
)

‚úÖ 5. Deletar documentos
db.usuarios.deleteOne({ nome: "Fulano" })
db.usuarios.deleteMany({ idade: { $lt: 30 } })

‚úÖ 6. Proje√ß√£o (mostrar campos espec√≠ficos)
db.usuarios.find({}, { nome: 1, _id: 0 })

‚úÖ 7. Filtros avan√ßados
db.usuarios.find({ idade: { $gt: 25 } })           // idade maior que 25
db.usuarios.find({ hobbies: { $in: ["correr"] } }) // se cont√©m hobby

‚úÖ 8. √çndices
db.usuarios.createIndex({ email: 1 })

‚úÖ 9. Ordenar e limitar
db.usuarios.find().sort({ idade: -1 }).limit(5)

‚úÖ 10. Agrega√ß√µes (ex: m√©dia de idade)
db.usuarios.aggregate([
  { $group: { _id: null, media: { $avg: "$idade" } } }
])

üîÅ Modelagem Exemplo
db.pedidos.insertOne({
  cliente: {
    nome: "Jo√£o",
    email: "joao@email.com"
  },
  itens: [
    { produto: "Teclado", preco: 100 },
    { produto: "Mouse", preco: 50 }
  ],
  data: new Date()
})

üìå Quando usar MongoDB?
Use quando:

Precisa de estrutura flex√≠vel (sem esquema fixo)
Precisa de velocidade de leitura/escrita
Precisa lidar com documentos complexos (aninhados)
Quer escalar facilmente com clusters
Quando n√£o h√° necessidade de relacionamentos/joins

Para instalar o MongoDB vamos usar o Docker: 

Docker √© uma plataforma que permite empacotar, distribuir e executar aplica√ß√µes em ambientes isolados chamados containers. Esses containers incluem tudo o que a aplica√ß√£o precisa para funcionar (c√≥digo, bibliotecas, depend√™ncias), garantindo que ela rode da mesma forma em qualquer lugar, seja no seu computador, em um servidor ou na nuvem.

Principais conceitos:
Imagem: √© como uma "fotografia" da aplica√ß√£o com tudo que ela precisa. Pode ser usada para criar containers.

Container: √© uma inst√¢ncia em execu√ß√£o de uma imagem. √â leve, r√°pido e isolado do sistema operacional.

Dockerfile: √© um arquivo com instru√ß√µes para criar uma imagem Docker.

Docker Hub: √© um reposit√≥rio online onde voc√™ pode encontrar e compartilhar imagens Docker.

Vantagens:
Portabilidade entre ambientes.
Redu√ß√£o de conflitos entre depend√™ncias.
Facilidade na automa√ß√£o de testes e deploy.
Resumindo: Docker facilita o desenvolvimento, a distribui√ß√£o e a execu√ß√£o de aplica√ß√µes de forma consistente, independente do ambiente.

Docker Compose √© uma ferramenta que permite definir e gerenciar m√∫ltiplos containers Docker como um √∫nico servi√ßo, usando um arquivo de configura√ß√£o chamado docker-compose.yml.

Para que serve:
Quando sua aplica√ß√£o depende de v√°rios servi√ßos (por exemplo, uma API, um banco de dados e um servi√ßo de cache), o Docker Compose facilita a cria√ß√£o e a execu√ß√£o de todos eles juntos com um √∫nico comando.

Exemplo de uso:
Um arquivo docker-compose.yml pode definir:
version: '3'
services:
  web:
    image: minha-api
    ports:
      - "8080:8080"
  db:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: senha

Exemplo nosso criado:
services:
  db:
    image: mongo
    container_name: db
    restart: always
    environment:
      MONGO_INITDB_ROOT_USERNAME: dio
      MONGO_INITDB_ROOT_PASSWORD: dio
    ports:
      - "27017:27017"
    volumes:
      - "C:/Users/Carlos/Desktop/Programa√ß√£o 2024 e Redes/DIO-Java-Bootcamp/dio/Aulas/MongoDB:/data/db"


Comandos principais:
docker-compose up: sobe todos os containers definidos.
docker-compose up -d: n√£o sei, mas usamos isso
docker-compose down: para e remove os containers.
docker-compose build: constr√≥i as imagens definidas no Dockerfile.

Vantagens:
Facilidade na orquestra√ß√£o de m√∫ltiplos containers.
Configura√ß√£o clara e reutiliz√°vel.
√ötil em ambientes de desenvolvimento e testes.

Resumo: O Docker Compose automatiza e simplifica a execu√ß√£o de aplica√ß√µes compostas por v√°rios containers, tudo configurado em um √∫nico arquivo.

COMO TENHO QUE APRENDER VOU USAR O MongoDB Compass QUE POSSUI UMA INTERFACE GR√ÅFICA PRA REALIZAR AS OPERA√á√ïES
N√ÉO VOU USAR O Mongo Shell (mongosh) ‚Äî Linha de comando!!!!

O compass tamb√©m possui MONGOSH!

h√° tamb√©m o Robo 3T (tamb√©m conhecido como Robomongo), ele √© uma excelente ferramenta GUI para visualizar e editar dados no MongoDB, especialmente leve e direto ao ponto.

No MongoDB, o termo cluster pode ter dois significados principais: clusters locais (implementados diretamente por voc√™) e clusters gerenciados na nuvem (MongoDB Atlas). Ambos s√£o formas de organizar e escalar seu banco de dados, mas com prop√≥sitos e complexidades diferentes.

Clusters Locais ‚Äî Replica Sets e Sharded Clusters
Replica Set: Alta Disponibilidade e Redund√¢ncia
Um Replica Set √© um grupo de servidores MongoDB que mant√©m c√≥pias id√™nticas dos seus dados. O objetivo principal √© garantir que seu banco de dados continue funcionando mesmo que um ou mais servidores fiquem indispon√≠veis. Em um replica set, h√° um servidor principal que recebe as opera√ß√µes de escrita, e servidores secund√°rios que replicam esses dados e podem assumir automaticamente em caso de falha do principal.

Vantagens do Replica Set:

Toler√¢ncia a falhas (alta disponibilidade)

Backup e manuten√ß√£o sem downtime

Melhora de desempenho em consultas de leitura, podendo distribuir leitura para r√©plicas secund√°rias

Replica sets s√£o essenciais para sistemas cr√≠ticos que n√£o podem parar.

Sharded Cluster: Escalabilidade Horizontal para Grandes Volumes
Um Sharded Cluster divide os dados entre m√∫ltiplos servidores, chamados shards. Cada shard cont√©m uma parte dos dados, e o cluster gerencia onde cada dado est√° armazenado. Isso permite que o MongoDB escale horizontalmente, suportando grandes volumes de dados e alta carga de leitura e escrita.

Vantagens do Sharding:

Suporte a Big Data e alta demanda

Distribui√ß√£o de carga entre v√°rios servidores

Permite que sua aplica√ß√£o cres√ßa sem perder performance

Sharding √© usado quando o volume de dados ou o n√∫mero de usu√°rios cresce demais para um √∫nico servidor.

Clusters em Nuvem ‚Äî MongoDB Atlas
O MongoDB Atlas √© um servi√ßo gerenciado que oferece clusters MongoDB na nuvem, rodando em provedores como AWS, Azure e Google Cloud. Ele facilita a cria√ß√£o, configura√ß√£o e escalabilidade dos clusters, cuidando da infraestrutura para voc√™.

Benef√≠cios do Atlas:

Deploy r√°pido e f√°cil de clusters em nuvem

Backups autom√°ticos, seguran√ßa, monitoramento e escalabilidade integrada

Possibilidade de come√ßar com um cluster gratuito para testes e aprendizado

Interface amig√°vel para gerenciamento sem precisar lidar com servidores

E no seu caso, com Docker local?
Ao rodar o MongoDB em um container Docker simples, voc√™ est√° usando um servidor standalone ‚Äî ou seja, um √∫nico n√≥, sem replica set nem sharding. Essa configura√ß√£o √© perfeita para desenvolvimento, aprendizado e aplica√ß√µes simples, mas n√£o tem toler√¢ncia a falhas nem escalabilidade.

Quando usar clusters de verdade?
Pequenos projetos e testes locais: MongoDB standalone (um n√≥ s√≥) √© suficiente.

Sistemas em produ√ß√£o que exigem alta disponibilidade: configure um Replica Set para garantir que o servi√ßo n√£o pare em caso de falha.

Aplica√ß√µes com grande volume de dados e alta demanda: use Sharding para distribuir carga e dados entre v√°rios servidores.

Quer praticidade e escalabilidade na nuvem: utilize o MongoDB Atlas para ter clusters gerenciados sem precisar configurar servidores.

Resumo Final
Clusters no MongoDB s√£o formas de organizar seu banco para que ele seja mais robusto e escal√°vel. Replica Sets protegem contra falhas, Sharded Clusters ampliam a capacidade, e clusters na nuvem facilitam o gerenciamento.

Se voc√™ est√° come√ßando, use o MongoDB standalone local (como voc√™ fez no Docker). Quando o projeto crescer, evolua para clusters para manter seu sistema est√°vel e r√°pido.

 Schema Design no MongoDB ‚Äì Conceitos e Boas Pr√°ticas
MongoDB √© um banco de dados NoSQL orientado a documentos, o que significa que n√£o exige um esquema fixo como bancos relacionais (SQL), mas isso n√£o significa aus√™ncia de planejamento. Um bom schema design √© essencial para garantir performance, escalabilidade e manuten√ß√£o do sistema.

üß† Conceitos Fundamentais
1. Documento (Document)
Unidade b√°sica de dados no MongoDB.

Usa formato BSON (similar a JSON).

Armazena dados de forma estruturada: { nome: "Carlos", idade: 30 }.

2. Cole√ß√£o (Collection)
Conjunto de documentos relacionados (como uma "tabela", mas sem esquema fixo).

Documentos de uma mesma cole√ß√£o podem ter estruturas diferentes ‚Äî mas n√£o √© recomendado sem necessidade.

3. Esquema flex√≠vel (Schema-less)
MongoDB n√£o exige um esquema fixo.

Mas voc√™ pode (e deve) definir um padr√£o l√≥gico de estrutura dos documentos (manualmente ou usando valida√ß√µes).

‚úÖ Boas Pr√°ticas de Schema Design
1. Modelar com base nos casos de uso
Pense em como os dados ser√£o lidos e consultados, n√£o apenas em como s√£o organizados.

Otimize para leitura, especialmente em aplica√ß√µes web/mobile.

üìå Exemplo:

Se voc√™ sempre precisa do cliente com os pedidos juntos, considere embutir os pedidos (embed).

Se os pedidos forem muitos ou acessados separadamente, use refer√™ncia (reference).

2. Embed ou Referenciar?
Estrat√©gia	Embed (Incorporar)	Reference (Refer√™ncia)
Quando usar	Dados que sempre aparecem juntos	Dados grandes ou com reuso
Exemplo	Endere√ßo do usu√°rio	Produtos em pedidos

üìç Dica:
99% dos acessos juntos ‚Üí embed

Muitos acessos separados / muitos dados ‚Üí reference

3. Evite documentos gigantes
MongoDB tem limite de 16 MB por documento.

Divida dados em m√∫ltiplos documentos se necess√°rio.

4. Use √≠ndices corretamente
√çndices aceleram buscas, mas consomem mem√≥ria.

Crie √≠ndices nos campos mais usados em:

find()

sort()

join (lookup)

aggregate()

5. Padronize nomes e estruturas
Use nomes de campos claros e consistentes.

Use camelCase (ex: dataNascimento) ou snake_case (data_nascimento), mas seja consistente.

Valida√ß√£o de esquema (opcional, mas recomendada)
Use validators para impor formato e obrigatoriedade de campos.

Exemplo:
{
  $jsonSchema: {
    bsonType: "object",
    required: ["nome", "email"],
    properties: {
      nome: { bsonType: "string" },
      email: { bsonType: "string" },
      idade: { bsonType: "int" }
    }
  }
}


7. Evite aninhamento profundo
Documentos muito aninhados dificultam leitura e indexa√ß√£o.

Limite o n√≠vel de profundidade (2 ou 3 n√≠veis no m√°ximo).

8. Projete com escalabilidade em mente
Pense em como os dados crescer√£o:

Muitos coment√°rios por post? Pode ser uma cole√ß√£o separada.

Milh√µes de pedidos por cliente? Use reference.

9. Documenta√ß√£o interna
Mesmo que MongoDB n√£o obrigue um esquema, documente a estrutura dos dados (para equipes futuras e manuten√ß√£o).

üìå Exemplo de Bom Design
Exemplo: Usu√°rio com endere√ßo embutido
{
  "nome": "Carlos",
  "email": "carlos@email.com",
  "endereco": {
    "rua": "Av. Brasil",
    "numero": 123,
    "cidade": "Rio de Janeiro"
  }
}

Exemplo: Pedido referenciando produto
{
  "clienteId": "123abc",
  "produtos": [
    { "produtoId": "prod1", "quantidade": 2 },
    { "produtoId": "prod2", "quantidade": 1 }
  ],
  "data": "2025-05-16"
}


 Erros comuns
Tratar MongoDB como se fosse relacional.

Inserir documentos desorganizados sem planejamento.

Usar embed com dados que crescem indefinidamente.

N√£o usar √≠ndices e reclamar de performance.

Misturar muito os tipos em uma mesma cole√ß√£o.

‚úÖ Conclus√£o
O MongoDB oferece liberdade, mas exige responsabilidade. Um bom schema:

Reflete seus casos de uso reais.

Equilibra entre embed e refer√™ncia.

√â projetado para performance, clareza e manuten√ß√£o.

üì¶ Diferen√ßa entre JSON e BSON
‚úÖ O que √© JSON?
JSON (JavaScript Object Notation) √© um formato de texto leve, amplamente utilizado para troca de dados entre sistemas, especialmente em aplica√ß√µes web.

Caracter√≠sticas:
Formato de texto leg√≠vel por humanos

Baseado em pares chave-valor

Suporta tipos como:

string
number
boolean
array
object
null
Exemplo:
{
  "nome": "Carlos",
  "idade": 30,
  "ativo": true
}


‚úÖ O que √© BSON?
BSON (Binary JSON) √© um formato bin√°rio derivado do JSON, criado pelo MongoDB para armazenar e transmitir dados de forma mais eficiente e com suporte a mais tipos.

Caracter√≠sticas:
Formato bin√°rio (n√£o leg√≠vel por humanos)

Mais eficiente para armazenamento e leitura em m√°quinas

Suporta tipos extras que o JSON n√£o tem, como:

Date
ObjectId
BinData (dados bin√°rios)
int32, int64, decimal128
Usado internamente pelo MongoDB
Exemplo equivalente (conceitual, pois BSON √© bin√°rio):
{
  "nome": "Carlos",
  "idade": 30,
  "nascimento": ISODate("1995-05-01T00:00:00Z"),
  "_id": ObjectId("6645f12e99e3b4f3d1a2b456")
}

A performance no MongoDB est√° diretamente ligada √† forma como os dados s√£o consultados e armazenados. Um dos principais recursos para melhorar a performance das consultas s√£o os √≠ndices.

√çndices funcionam como atalhos que o banco de dados usa para localizar documentos de forma mais r√°pida, sem precisar varrer toda a cole√ß√£o. Eles s√£o especialmente √∫teis em campos que s√£o frequentemente usados em filtros (find), ordena√ß√µes (sort) ou buscas espec√≠ficas.

Existem v√°rios tipos de √≠ndices no MongoDB, como:

√çndice padr√£o (single field) ‚Äì em um √∫nico campo.

√çndice composto ‚Äì em dois ou mais campos.

√çndice texto ‚Äì usado para buscas por palavras em campos de texto.

√çndice geoespacial ‚Äì para localiza√ß√£o geogr√°fica.

Sem √≠ndices adequados, as consultas podem ficar lentas, principalmente em cole√ß√µes grandes, pois o banco precisa verificar documento por documento (chamado de collection scan).

Portanto, criar os √≠ndices certos nos campos mais consultados √© essencial para garantir boa performance nas aplica√ß√µes que usam MongoDB.

As agrega√ß√µes no MongoDB s√£o uma forma poderosa de processar dados e retornar resultados computados. Em vez de simplesmente buscar documentos como eles est√£o armazenados, o framework de agrega√ß√£o permite que voc√™ execute uma s√©rie de opera√ß√µes (um "pipeline") para transformar e combinar esses dados.

Pense nisso como uma linha de montagem: os documentos entram em uma extremidade, passam por v√°rias esta√ß√µes (est√°gios de agrega√ß√£o), e um resultado transformado sai na outra extremidade.

Principais Conceitos:

Pipeline de Agrega√ß√£o (Aggregation Pipeline):

√â a abordagem mais comum e recomendada para agrega√ß√µes.

Consiste em uma sequ√™ncia (array) de est√°gios.

Cada est√°gio recebe os documentos do est√°gio anterior, processa-os e passa o resultado para o pr√≥ximo est√°gio.

A ordem dos est√°gios importa muito.

Est√°gios (Stages):

Cada est√°gio realiza uma opera√ß√£o espec√≠fica nos documentos.

Existem diversos operadores de est√°gio, como:

$match: Filtra documentos, similar ao find(). √â bom coloc√°-lo no in√≠cio para reduzir o volume de dados processados.

$group: Agrupa documentos por uma chave especificada e permite aplicar "acumuladores" para calcular valores (soma, m√©dia, contagem, etc.) dentro de cada grupo. Este √© o cora√ß√£o de muitas agrega√ß√µes.

$project: Remodela os documentos. Pode incluir/excluir campos, adicionar novos campos computados, renomear campos.

$sort: Ordena os documentos.

$limit: Limita o n√∫mero de documentos passados para o pr√≥ximo est√°gio.

$skip: Pula um n√∫mero especificado de documentos.

$unwind: Desconstr√≥i um campo do tipo array, criando um documento de sa√≠da para cada elemento do array.

$lookup: Realiza um "left outer join" com outra cole√ß√£o no mesmo banco de dados.

$out: Escreve os resultados da agrega√ß√£o em uma nova cole√ß√£o (cuidado, pois substitui a cole√ß√£o se ela existir).

$merge: Escreve os resultados da agrega√ß√£o em uma cole√ß√£o especificada, permitindo atualizar documentos existentes ou inserir novos.

Operadores de Express√£o (Expression Operators):

Usados dentro de alguns est√°gios (especialmente $group e $project) para realizar c√°lculos ou manipula√ß√µes.

Acumuladores (usados principalmente com $group):

$sum: Soma valores num√©ricos.

$avg: Calcula a m√©dia.

$min: Encontra o valor m√≠nimo.

$max: Encontra o valor m√°ximo.

$push: Adiciona um valor a um array no documento agrupado.

$addToSet: Adiciona um valor a um array apenas se ele ainda n√£o existir no array.

$first: Retorna o valor do primeiro documento do grupo.

$last: Retorna o valor do √∫ltimo documento do grupo.

Outros operadores de data, string, l√≥gicos, aritm√©ticos, etc.

Quando usar Agrega√ß√µes?

Para realizar c√°lculos complexos sobre os dados (somas, m√©dias, contagens).

Para agrupar dados e obter insights resumidos.

Para transformar a estrutura dos documentos para relat√≥rios ou outras an√°lises.

Para juntar dados de m√∫ltiplas cole√ß√µes (com $lookup).

Quando voc√™ precisa processar dados no lado do servidor para evitar transferir grandes volumes de dados para a aplica√ß√£o cliente.

Outras Formas de Agrega√ß√£o (Menos Comuns Hoje em Dia):

MapReduce: Um paradigma mais antigo e flex√≠vel, por√©m mais complexo de escrever e geralmente mais lento que o Aggregation Pipeline para a maioria dos casos de uso. √â √∫til para cen√°rios muito espec√≠ficos onde o pipeline n√£o √© suficiente.

Comandos de Agrega√ß√£o Simples: count(), distinct(). S√£o convenientes para opera√ß√µes simples, mas s√£o internamente implementados usando o framework de agrega√ß√£o.

Em resumo, o Aggregation Pipeline √© a ferramenta principal e mais eficiente para realizar an√°lises e transforma√ß√µes de dados complexas diretamente no MongoDB. Ele oferece uma sintaxe declarativa e poderosa para lidar com uma vasta gama de necessidades de processamento de dados.

üéØ O que √© o DBeaver?
O DBeaver √© uma ferramenta gr√°fica (GUI) para gerenciar bancos de dados. Ele √© tipo um "Workbench mais poderoso e mais universal".

‚úÖ O que ele faz?
Conecta com v√°rios tipos de banco de dados: MySQL, PostgreSQL, Oracle, SQLite, SQL Server, MariaDB, MongoDB, e mais.

Permite criar, visualizar, editar tabelas e dados.

Executa queries SQL com destaque de sintaxe e hist√≥rico.

Mostra rela√ß√µes entre tabelas visualmente (tipo diagramas ER).

√â √≥timo pra trabalhar com Docker, porque voc√™ conecta ao banco que roda dentro de um container com alguns cliques.

üÜö DBeaver x MySQL Workbench
| Funcionalidade       | DBeaver    | MySQL Workbench |
| -------------------- | ---------- | --------------- |
| Multi-banco          | ‚úÖ Sim      | ‚ùå S√≥ MySQL      |
| Open Source          | ‚úÖ Sim      | ‚úÖ Sim           |
| Interface moderna    | ‚úÖ Boa      | üü° M√©dia        |
| Extens√≠vel (plugins) | ‚úÖ Sim      | ‚ùå N√£o           |
| Leveza/performance   | üü° Mediana | ‚úÖ Boa com MySQL |

üß™ Exemplo pr√°tico:
Se voc√™ tem um MySQL rodando no Docker, no DBeaver √© s√≥:

Abrir o app.

Clicar em "New Database Connection".

Escolher MySQL.

Colocar:

Host: localhost

Porta: 3306

Usu√°rio: root (ou o que tiver)

Senha: (aquela do -e MYSQL_ROOT_PASSWORD)

Conectar.

E pronto, voc√™ visualiza o banco sem precisar decorar comandos, montar CLI ou lidar com configura√ß√£o chata.

        (Conte√∫do escrito no READme do reposit√≥rio "resumo-cloudAzure")
        Introdu√ß√£o √† Computa√ß√£o em Nuvem AZ-900

AZ 900 √© uma certifica√ß√£o de entrada em cloud (importante!)

A Azure possui servi√ßos gratuitos e pagos, √© recomendado excluir os servi√ßos, laborat√≥rios e outras coisas que usamos para aprendizado para evitar cobran√ßas futuras

Computa√ß√£o em Nuvem:

√â o fornecimento de servi√ßos de computa√ß√£o (como servidores, armazenamento, bancos de dados, redes, software, an√°lise e intelig√™ncia) por meio da internet (‚Äúa nuvem‚Äù). Ela permite inova√ß√µes mais r√°pidas, recursos escal√°veis sob demanda e economia de custos, pois elimina a necessidade de manter datacenters f√≠sicos locais (as chamadas "salas frias" com servidores).

A computa√ß√£o em nuvem √© viabilizada principalmente por virtualiza√ß√£o, uma tecnologia que permite que um √∫nico servidor f√≠sico simule m√∫ltiplas m√°quinas virtuais (VMs). Isso otimiza o uso dos recursos computacionais, aumenta a flexibilidade e facilita a automa√ß√£o e o gerenciamento.

Modelos de nuvem

üè¢ 1. Nuvem Privada (Private Cloud) ou "On premises"
Infraestrutura exclusiva para uma √∫nica organiza√ß√£o.

Pode estar localizada no pr√≥prio datacenter da empresa ou hospedada por terceiros.

Mais controle e seguran√ßa, uma vez que a organiza√ß√£o √© respons√°vel por operar os servi√ßos que fornecem, ideal para empresas com exig√™ncias rigorosas (banco, governo, etc.), n√£o fornece acesso aos usu√°rios fora da organiza√ß√£o.

üìå Vantagens: seguran√ßa, personaliza√ß√£o, conformidade.


‚òÅÔ∏è 2. Nuvem P√∫blica (Public Cloud)
Recursos (servidores, armazenamento, etc.) s√£o fornecidos por terceiros (como AWS, Azure, Google Cloud) e outros provedores de hosting.

Tudo √© acessado pela internet via conex√£o de rede segura.

Compartilhada entre m√∫ltiplos clientes.

Exemplo: usar o Google Drive ou hospedar um site na AWS.

üìå Vantagens: escalabilidade, baixo custo inicial, sem necessidade de gerenciar infraestrutura.


üîÅ 3. Nuvem H√≠brida (Hybrid Cloud)
Combina√ß√£o de nuvem p√∫blica e privada.

Permite mover dados e aplica√ß√µes entre ambientes, conforme a necessidade.

Equil√≠brio entre seguran√ßa e escalabilidade.

üìå Exemplo: manter dados sens√≠veis em uma nuvem privada e usar nuvem p√∫blica para testes ou picos de demanda.


üåê 4. Nuvem Comunit√°ria (Community Cloud)
Compartilhada por v√°rias organiza√ß√µes com interesses ou requisitos comuns (por exemplo, √≥rg√£os governamentais ou hospitais).

Infraestrutura pode ser gerenciada por uma ou mais organiza√ß√µes, ou por terceiros.

üìå Vantagens: colabora√ß√£o segura entre entidades, custo dividido, foco em necessidades espec√≠ficas.


‚òÅÔ∏èüîÄ Multicloud
Multicloud √© o uso de dois ou mais provedores de nuvem p√∫blica diferentes ao mesmo tempo ‚Äî por exemplo, uma empresa usando AWS + Azure + Google Cloud.

üü° Importante: Multicloud ‚â† Nuvem h√≠brida

Multicloud = v√°rias nuvens p√∫blicas diferentes.

H√≠brida = combina√ß√£o de nuvem p√∫blica com nuvem privada.

‚úÖ Por que usar multicloud?
Evitar depend√™ncia de um √∫nico fornecedor ("vendor lock-in").

Aproveitar o melhor de cada servi√ßo (por exemplo, usar IA do Google e banco de dados da AWS).

Alta disponibilidade e redund√¢ncia (se um provedor falhar, outro assume).

Custos otimizados, escolhendo o mais barato para cada servi√ßo.

üìå Exemplo pr√°tico:
Uma empresa pode:

Hospedar seu site na AWS,

Usar o banco de dados do Azure,

Armazenar backups no Google Cloud.


Compara√ß√£o de modelos de nuvem

Nuvem publica / Nenhuma despesa de capital para escalar verticalmente, aplicativos podem ser provisionados e desprovisionados rapidamente, organiza√ß√µes paga apenas pelo o que utilizam

Nuvem privada / as organiza√ß√µes tem controle total sobre recursos e seguran√ßa, e s√£o respons√°veis pela manuten√ß√£o e pelas atualiza√ß√µes de hardware e software

Nuvem Hibrida / as organiza√ß√µes determinam onde executar os seus aplicativos, as organiza√ß√µes controlam a seguran√ßa e a confirmidade e requisitos legais, fornecem maior flexibilidade


CAPEX (Capital Expenditure) √© o gasto com bens de capital ou investimentos de longo prazo, como a compra de servidores, equipamentos ou constru√ß√£o de datacenters. Esses gastos costumam ter um valor inicial alto e s√£o usados por v√°rios anos, sendo registrados como ativos e depreciados com o tempo. Na era pr√©-nuvem, empresas tinham grandes despesas de CAPEX para montar suas pr√≥prias infraestruturas de TI. Com a computa√ß√£o em nuvem, muitos desses custos foram substitu√≠dos por OPEX, j√° que agora as empresas alugam recursos ao inv√©s de compr√°-los, o valor do Capex se reduz com o tempo, ao contr√°rio do Opex onde o valor aumenta conforme a necessidade operacional.

OPEX (Operational Expenditure) √© o gasto operacional do dia a dia, como pagamento de servi√ßos, assinaturas e manuten√ß√£o. Na computa√ß√£o em nuvem, √© o modelo onde a empresa paga pelo uso dos recursos (como servidores, armazenamento ou software) sem precisar compr√°-los. √â mais flex√≠vel, com custos menores no in√≠cio e pagamento conforme o uso, sendo ideal para escalar rapidamente sem grandes investimentos iniciais.

Modelo baseado em consumo √© operado atrav√©s dos provedores de servi√ßos, onde os usu√°rios finais pagam somente pelos recursos que utilizam, possui uma melhor previs√£o de custos com pre√ßos para recursos e servi√ßos individuais, com cobran√ßa baseada no seu uso real



Jumpserver -  √© uma plataforma open-source de bastion host (ou "jump host") usada para gerenciar o acesso remoto seguro a servidores e dispositivos de rede. Ele atua como um ponto intermedi√°rio entre os usu√°rios e os servidores de destino, controlando, monitorando e registrando todas as conex√µes SSH, RDP, etc. √â muito usado para refor√ßar a seguran√ßa de ambientes de TI, permitindo auditoria de acessos e evitando conex√µes diretas aos servidores cr√≠ticos.


        Lab Azure

Evite usar recursos 'Vers√£o pr√©via' uma vez que eles podem ser 'inst√°veis' e isso na produ√ß√£o √© ca√≥tico!

Beneficios da computa√ß√£o em nuvem

Alta Disponibilidade

alta disponibilidade que se concentra em garantir a disponibilidade m√°xima, independentemente de interrup√ß√µes ou eventos que possam ocorrer - Sempre funcionando, acesso de m√∫ltiplos locais, recursos sempre dispon√≠veis
 
 üìà SLA da Azure ‚Äì Resumo
SLA (Service Level Agreement) √© o acordo de n√≠vel de servi√ßo oferecido pela Microsoft Azure que garante uma disponibilidade m√≠nima dos servi√ßos de nuvem.

‚è± Exemplos comuns de SLA na Azure:
SLA	Tempo m√°ximo de indisponibilidade | (mensal)
99% |	7h 12min
99,9% |	43min
99,95% |	21,6min
99,99% |	4,32min

Quanto maior o SLA, menor o tempo que o servi√ßo pode ficar fora do ar no m√™s.

‚ö†Ô∏è Importante:
O SLA varia conforme o servi√ßo e a arquitetura. Por exemplo, uma VM sozinha pode ter 99,9%, mas com redund√¢ncia (conjunto de disponibilidade) sobe para 99,95% ou mais.

Para alcan√ßar alta disponibilidade, √© preciso configurar corretamente zonas de disponibilidade, balanceamento de carga, backups, etc.

O site oficial da Microsoft Azure para verificar o status dos servi√ßos em tempo real √©:

üîó https://status.azure.com

‚úÖ O que voc√™ encontra l√°:
Disponibilidade global dos servi√ßos da Azure.

Incidentes ou interrup√ß√µes em regi√µes espec√≠ficas.

Hist√≥rico de eventos passados.

Informa√ß√µes por produto e regi√£o.

Dica: Para ambientes cr√≠ticos, √© bom monitorar esse site regularmente ou configurar alertas por e-mail.


üìä Escalabilidade
Escalabilidade √© a capacidade de aumentar ou reduzir recursos computacionais para atender √† demanda de uma aplica√ß√£o ou servi√ßo.

Quando a necessidade de processamento, armazenamento ou tr√°fego cresce, o sistema pode escalar para cima (scale-up) ou escalar para fora (scale-out) automaticamente ou sob demanda.

Da mesma forma, se a demanda cair, os recursos podem ser reduzidos, ajudando a otimizar os custos.

üìå Principais pontos:

Permite crescimento eficiente conforme o neg√≥cio exige.

Reduz custos ao evitar superdimensionamento.

Voc√™ paga apenas pelo que realmente usa.

‚ö†Ô∏è Escalabilidade e elasticidade s√£o conceitos parecidos, mas:

Escalabilidade: capacidade de ajustar recursos conforme necess√°rio.

Elasticidade: capacidade de ajustar recursos automaticamente e rapidamente conforme as varia√ß√µes de carga.


üìà Elasticidade
Elasticidade √© a capacidade da nuvem de aumentar ou reduzir automaticamente os recursos computacionais conforme a demanda.

Um exemplo cl√°ssico √© durante a Black Friday, onde um site pode receber muito mais acessos do que o normal. Nesse cen√°rio:

A nuvem expande os recursos automaticamente (como inst√¢ncias de servidor, largura de banda, etc.) para atender ao pico de demanda.

Ap√≥s o evento, com a queda no tr√°fego, os recursos s√£o reduzidos automaticamente, evitando desperd√≠cio.

üìå Benef√≠cios:

Alta performance sob demanda.

Economia de custos (voc√™ s√≥ paga pelo que precisa no momento).

Escalabilidade inteligente, sem interven√ß√£o manual.


‚úÖ Confiabilidade
Confiabilidade √© a capacidade de um sistema ou servi√ßo em nuvem de funcionar de forma consistente e cont√≠nua, mesmo diante de falhas, picos de demanda ou problemas t√©cnicos, o design descentralizado da nuvem a torna confi√°vel e resiliente

Um servi√ßo confi√°vel:

Minimiza o tempo de inatividade (downtime).

Garante disponibilidade alta (geralmente com SLA de 99,9% ou mais).

Possui redund√¢ncia e recupera√ß√£o de desastres integradas.

√â monitorado continuamente para detectar e corrigir falhas automaticamente.

üìå Como a nuvem garante confiabilidade:

Replica√ß√£o de dados em m√∫ltiplas zonas ou regi√µes.

Balanceamento de carga.

Backups autom√°ticos.

Failover (redirecionamento autom√°tico em caso de falha).

A confiabilidade √© essencial para garantir que aplica√ß√µes cr√≠ticas continuem funcionando sem interrup√ß√µes, mesmo em situa√ß√µes adversas.


üìè Previsibilidade
Previsibilidade na computa√ß√£o em nuvem se refere √† capacidade de estimar custos, desempenho e comportamento dos recursos de forma antecipada e controlada, esses aspectos s√£o influenciados pelo Microsft Azure Well-Architected Framework

Com a nuvem, √© poss√≠vel:

Ter previs√£o de custos, j√° que os servi√ßos seguem modelos baseados em consumo (pay-as-you-go).

Estimar o desempenho esperado com base em SLAs e especifica√ß√µes t√©cnicas.

Planejar capacidades futuras com mais seguran√ßa.

üìå Benef√≠cios da previsibilidade:

Controle financeiro: f√°cil monitorar gastos e evitar surpresas na fatura.

Planejamento estrat√©gico: ajuda a dimensionar infraestrutura de forma mais eficaz.

Estabilidade operacional: evita picos ou quedas inesperadas de desempenho.

Muitos provedores, como a Azure, oferecem calculadoras de custo e ferramentas de monitoramento que ajudam a manter a previsibilidade dos recursos e dos investimentos.


üîê Seguran√ßa
Seguran√ßa na computa√ß√£o em nuvem envolve o conjunto de pr√°ticas, tecnologias e pol√≠ticas usadas para proteger dados, aplica√ß√µes e infraestrutura contra acessos n√£o autorizados, vazamentos e ataques cibern√©ticos.

Os provedores de nuvem (como Azure, AWS e Google Cloud) implementam camadas robustas de seguran√ßa para garantir a prote√ß√£o dos dados dos clientes, incluindo:

Criptografia de dados em tr√¢nsito e em repouso.

Controle de acesso com autentica√ß√£o multifator (MFA) e identidade baseada em fun√ß√£o (RBAC).

Firewalls e redes virtuais seguras.

Monitoramento cont√≠nuo e alertas contra atividades suspeitas.

Backups e recupera√ß√£o de desastres.

üìå Responsabilidade compartilhada:

O provedor √© respons√°vel pela seguran√ßa da nuvem (infraestrutura).

O cliente √© respons√°vel pela seguran√ßa na nuvem (dados, acessos, configura√ß√µes).

A seguran√ßa √© um dos pilares mais importantes da nuvem e precisa ser considerada desde o planejamento at√© a opera√ß√£o dos servi√ßos, e a implementa√ß√£o das configura√ß√µes de seguran√ßa por parte dos clientes devem ser feitas de forma correta!

Se voc√™ quiser o controle m√°ximo da seguran√ßa, a infraestrutura como servi√ßo ir√° fornecer os recursos fisicos, mas permitir√° que voc√™ gerencie os sistemas operacionais e o software instalado, incluindo aplica√ß√£o de patches e manuten√ß√£o

üõ°Ô∏è O que s√£o Ap√≥lices no Azure (Azure Policy)
üìå Defini√ß√£o:
Azure Policy √© um servi√ßo que permite criar, atribuir e gerenciar regras (pol√≠ticas) que for√ßam padr√µes ou restri√ß√µes nos recursos do Azure. Isso ajuda a impedir configura√ß√µes incorretas e a manter conformidade com normas internas ou externas.

‚úÖ Exemplos de uso:
Restringir regi√µes: impedir a cria√ß√£o de recursos fora de uma regi√£o espec√≠fica (por exemplo, s√≥ permitir "Brazil South").

Obrigar tags: exigir que todo recurso criado tenha tags como projeto, ambiente, ou owner.

Controlar tipos de VMs: permitir apenas determinados tamanhos ou fam√≠lias de m√°quinas virtuais.

Enfor√ßar criptografia: garantir que discos estejam sempre criptografados.

üîÑ Como funciona:
Voc√™ cria ou usa uma pol√≠tica pronta (Azure oferece v√°rias built-in).

Atribui essa pol√≠tica a um escopo (assinatura, grupo de recursos, etc).

O Azure aplica e monitora automaticamente se os recursos est√£o em conformidade.

Se algo estiver fora da regra, pode bloquear a a√ß√£o ou apenas alertar (modo de auditoria).

üß© Tipos de a√ß√µes:
Deny (negar cria√ß√£o/altera√ß√£o)

Audit (somente registrar viola√ß√£o)

Append (adicionar propriedades a um recurso)

DeployIfNotExists (implantar algo automaticamente se faltar)

üß† Import√¢ncia:
Azure Policy √© fundamental para:

Governan√ßa e seguran√ßa

Conformidade com normas (LGPD, ISO, etc)

Controle de custos

Padroniza√ß√£o de ambientes


üèõÔ∏è Governan√ßa na Nuvem
Governan√ßa √© o conjunto de processos, regras, pol√≠ticas e ferramentas que ajudam a organizar, controlar e padronizar o uso da nuvem dentro de uma organiza√ß√£o.

A auditoria baseada em nuvem ajuda a sinalizar qualquer recurso que esteja fora da conformidade com seus padr√µes corporativos e fornece estrategias de mitiga√ß√£o

Dependendo do seu modelo operacional, patches de software e atualiza√ß√µes tamb√©m podem ser aplicados automaticamente, o que juda na governan√ßa e na seguran√ßa

Ao estabelecer uma presen√ßa de governan√ßa o mais cedo possivel, voce poder√° manter sua presen√ßa de nuvem atualizada, protegida e bem gerenciada

Ela garante que os recursos sejam utilizados de forma segura, eficiente, conforme as normas e com controle de custos.

üéØ Objetivos da governan√ßa:
Evitar desperd√≠cios e uso indevido de recursos.

Manter conformidade com requisitos legais e regulat√≥rios.

Padronizar configura√ß√µes e boas pr√°ticas.

Proteger dados sens√≠veis e controlar acessos.

Monitorar o ambiente em tempo real.
üõ†Ô∏è Ferramentas e pr√°ticas de governan√ßa no Azure:
| Recurso                                          | Fun√ß√£o                                                                   |
| ------------------------------------------------ | ------------------------------------------------------------------------ |
| **Azure Policy**                                 | Define e aplica regras de conformidade automaticamente.                  |
| **Management Groups**                            | Organiza assinaturas em uma hierarquia para aplicar pol√≠ticas em escala. |
| **Resource Locks**                               | Impede a exclus√£o ou modifica√ß√£o acidental de recursos cr√≠ticos.         |
| **Tags**                                         | Ajudam a classificar e rastrear recursos (ex: por projeto ou ambiente).  |
| **Azure Blueprints**                             | Agrupamento de pol√≠ticas, RBAC, e recursos para padronizar ambientes.    |
| **RBAC (Controle de Acesso Baseado em Fun√ß√µes)** | Controla quem pode fazer o qu√™ com quais recursos.                       |

üìå Exemplo pr√°tico:
Voc√™ pode criar uma pol√≠tica para garantir que:

Todos os recursos estejam em uma regi√£o espec√≠fica.

Todo recurso tenha uma tag com o nome do projeto.

Apenas VMs aprovadas possam ser criadas.


üß© Gerenciabilidade
Gerenciabilidade na computa√ß√£o em nuvem refere-se √† capacidade de monitorar, controlar, configurar e otimizar os recursos e servi√ßos de forma eficiente e centralizada.

Ela permite que administradores e equipes de TI tenham visibilidade e controle total do ambiente em nuvem, garantindo que tudo funcione corretamente, com seguran√ßa e dentro dos padr√µes definidos.

Um dos principais beneficios da computa√ß√£o em nuvem s√£o as op√ß√µes de capacidade de gerenciamento, h√° dois tipos decapacidade de gerenciameto para a computa√ß√£o em nuvem que aprenderemos, e ambos  trazem excelentes beneficios

Gerenciamento da nuvem diz respeito a gerenciar os seus recursos, por exemplo: escalar automaticamente a implanta√ß√£o de recursos com base nas necessidades, implantar recursos com base em um modelo pr√©-configurado, removendo as necessidades de configura√ß√µes manuais, isso pode ser feito usando tamb√©m APIs e poweshell al√©m √© claro do portal da Azure!

üéØ Objetivos da gerenciabilidade:
Monitoramento cont√≠nuo de desempenho, disponibilidade e seguran√ßa.

Automa√ß√£o de tarefas administrativas (provisionamento, escalonamento, alertas).

Auditoria e rastreamento de atividades dos usu√°rios.

Organiza√ß√£o e categoriza√ß√£o de recursos (como via tags).

Facilidade na tomada de decis√µes, com base em dados e relat√≥rios.

üõ†Ô∏è Ferramentas de Gerenciabilidade no Azure:
| Recurso                   | Fun√ß√£o                                                                  |
| ------------------------- | ----------------------------------------------------------------------- |
| **Azure Monitor**         | Coleta m√©tricas, logs e eventos para monitoramento em tempo real.       |
| **Azure Log Analytics**   | Analisa logs e fornece insights detalhados sobre o ambiente.            |
| **Azure Advisor**         | Sugest√µes de boas pr√°ticas para melhorar desempenho, seguran√ßa e custo. |
| **Azure Cost Management** | Monitoramento e controle de gastos e or√ßamentos.                        |
| **Azure Automation**      | Automa√ß√£o de tarefas repetitivas (como desligar VMs fora do hor√°rio).   |

üìå Benef√≠cios:
Visibilidade total do ambiente.

Redu√ß√£o de falhas com alertas e automa√ß√µes.

Maior efici√™ncia operacional.

Suporte √† governan√ßa e conformidade.

---- Fim anexo README

