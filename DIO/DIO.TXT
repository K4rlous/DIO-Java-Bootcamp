BootCamp Bradesco 2025

                Introdu√ß√£o √† plataforma Java:

Pilares POO - Classes e objetos, Encapsulamento, Abstra√ß√£o, Heran√ßa, Polimorfismo

C√≥digo -> Bytecode -> ....

Bytecode e JVM tornam o Java 

A JVM transforma o Bytecode em algoritmo que ser√° interpretado pelo sistema!

WORA (Write once, run anywhere)

Robustez: Gerenciamento de mem√≥ria forte, coleta de lixo, tratamento de exce√ß√£o e mecanismos de verifica√ß√£o de tipo de dados

Seguran√ßa: Recursos de criptografia e descriptografia

Java compila gerando Bytecode e a JVM (Java Virtual Machine) interpreta o arquivo em Bytecode durante a execu√ß√£o

Thread = subprocesso leve e independente de um programa em execu√ß√£o, Java √© multithread logo possui v√°rios threads sendo executados simultaneamente

Java = Cidade de origem de um tipo de caf√© 


                Ambiente de desenvolvimento Java

Fun√ß√µes com autocomplete e inteliSense, formata√ß√£o de palavras e blocos de C√≥digo, an√°lises de erro de sintaxe, compila√ß√£o de programas e depura√ß√£o (acompanhamento) de execu√ß√£o do programa

IDeS principais: Eclipse, Netbeans, Intellij, Vscode

Maven = Umas das formas de empacotamento de projetos em java, ferramenta de automa√ß√£o de compila√ß√£o tamb√©m usada para construir e gerenciar projetos escritos em C#, Ruby, Scala, e outras linguagens

Snippet = Termo de programa√ß√£o para uma pequena regi√£o de c√≥digo-fonte reutiliz√°vel, c√≥digo de m√°quina ou texto. Normalmente, estas s√£o unidades operacionais formalmente definidas para serem incorporadas em m√≥dulos de programa√ß√£o maiores.

Instalar o JDK (Vscode automotiza com o Java Coding pack, que inclui o Vscode, JDK e extens√µes √∫teis e essenciais!) ele tamb√©m pode ser usado para atualizar um Vscode sem o JDK e as extens√µes!

O Eclipse possui vers√µes (packages) para desenvolvimento Java puro e uma vers√£o espec√≠fica para desenvolvimento Web! a escolha de diret√≥rio no Eclipse √© meio chata, mas uma conven√ß√£o legal √©: c/dev/ws/'trabalho' / dev de desenvolvimento, ws de workspace! e c/dev/projetos/'projeto' para projetos!


JDK PATH = c://Arquivos de Programas / Java / JDK (v√°rias vers√µes?)

No CMD 'java -version' retorna a vers√£o atual do Java instalado

Todo projeto Java sem um sistema de gerenciamento de projetos (como o Maven) possui pastas como 'lib', 'src' e arquivos que documentam a estrutura do projeto como um todo como o 'readme' que inclui informa√ß√µes sobre o projeto

A integra√ß√£o do Vscode com o Github, permite usar o Gitclone no Vscode para clonar nossos reposit√≥rios, CTRL + SHIFT + P para criar novos projetos Java e ver outras funcionalidades!

JRE (Java Runtime Enviroment) √© necess√°rio apenas para rodar c√≥digo Java, e n√£o desenvolver!

As quatro principais plataformas de desenvolvimento Java s√£o: 
Java SE (Java Platform, Standard Edition)
Java EE (Java Platform, Enterprise Edition)
Java ME (Java Platform, Micro Edition)
Java FX

                Versionamento de C√≥digo com Git e GitHub 

Controlam as vers√µes de um arquivo ao longo do tempo, registram hist√≥rico de atualiza√ß√µes do arquivo, gerenciam quais foram as altera√ß√µes, datas, autores e etc. Organiza√ß√£o, Controle e Seguran√ßa

Tipos: VCS Centralizado (CVCS) = Centralizam os dados em um servidor <- se ficar fora do ar o projeto fica inacess√≠vel, se houver perca de dados (e tu n√£o tiver backup) todo o projeto √© perdido

VCS Distribuido (DVCS) = Clona o reposit√≥rio incluindo o hist√≥rico de vers√µes, cada clone √© como um backup, possibilita fluxo de trabalho flexivel, possibilita trabalhar sem rede de internet!

O Git √© um sistema de controle de vers√£o distribu√≠do amplamente usado por desenvolvedores para gerenciar projetos de software. Ele permite que voc√™ acompanhe mudan√ßas no c√≥digo, trabalhe em equipe simultaneamente e volte a vers√µes anteriores quando necess√°rio. O Git organiza o hist√≥rico de altera√ß√µes em "commits", facilitando o rastreamento e a colabora√ß√£o eficiente. Com ele, voc√™ pode criar ramifica√ß√µes (branches) para desenvolver novos recursos ou corrigir bugs sem afetar o c√≥digo principal. 

git clone -> Clona um reposit√≥rio git existente para um novo diret√≥rio local
git commit -> Salva as altera√ß√µes no reposit√≥rio
git pull -> Puxa as altera√ß√µes do reposit√≥rio remoto para o local (busca e mescla)
git push -> Empurra as altera√ß√µes do reposit√≥rio local para o remoto
commit -> pull -> push
git --version no CMD pra ver a vers√£o do Git

GitBash (Aberto em algum diret√≥rio) permite usar comandos para configurar o Git / CTRL + L limpa o terminal!
git config - permite ver altera√ß√µes, tais como alterar as vari√°veis de configura√ß√£o

Como todos os nossos reposit√≥rios tem de estar em nosso nome as altera√ß√µes devem estar em escopo global

git config --global user.name "Fulano" / Definir o nome do usu√°rio
git config --global user.email fulano@gmail.com / Definir o email do usu√°rio
Ambos comandos sem argumentos (nome ou email) v√£o retornar os nomes e emails respectivamente usados

Esses dados ser√£o vinculados aos commits, mudar o nome ou email n√£o ir√° alterar commits j√° feitos!

git config init.defaultBranch / Retorna o nome da branch
git config --global init.defaultBranch algo / Muda o nome da branch para 'algo'

git config --global --list / Lista todas as configura√ß√µes globais (sem o global ia mostrar tudo)

O Github √© uma plataforma de hospedagem de c√≥digo para controle de vers√£o com Git e colabora√ß√£o

(Ela fez o login no Git com o Token do Github??)
N√≥s usamos SSH para logar (Secure Shell) OU N√ÉO?

git config --global credential.helper store / Salva as cred√™nciais 
git config --global credential.helper cache / Salva temporariamente (util se dividir a m√°quina)
git config --global credential.helper / Mostra como est√° salvando

git config --global --show-origin credential.helper / Mostra onde as cred√™nciais est√£o salvas e o 'modo' dela

Criando e Clonando Reposit√≥rios

Existem duas formas de obter um reposit√≥rio Git na sua m√°quina: 1. Transformando um diret√≥rio local que n√£o est√° sob controle de vers√£o, num reposit√≥rio Git; 2. Clonando um reposit√≥rio Git existente

Comandos do GitBash
1¬∞
mkdir repo-local / Cria o diret√≥rio 'repo-local'
cd repo-local / Muda o diret√≥rio para 'repo-local'
git init / Transforma o diret√≥rio atual em um reposit√≥rio git (main)
cd .git / Muda o diret√≥rio para 'git' (git_dir)
ls / Lista os arquivos (entre eles h√° um arquivo de configura√ß√µes)
cat config / Mostra os dados do arquivo de configura√ß√µes mencionado.

2¬∞
Copia-se o c√≥digo https do reposit√≥rio no Github
git clone 'url' / Copia o reposit√≥rio da url
git clone 'url' 'nome' / Copia o reposit√≥rio da url e muda o nome da pasta para 'nome'


git remote -v / Mostra os reposit√≥rios remotos aos quais est√° vinculado
git remote add 'nome' 'url do reposit√≥rio ao qual queremos vincular' (padr√£o deixar o nome 'origin') / Conecta o reposit√≥rio local com um reposit√≥rio remoto

git clone 'url' --branch 'nome-da-branch' --single-branch / Clona apenas a branch escolhida pelo nome, se n√£o passar o nome ele clona a principal seja a 'main' ou a 'master'

git status / √© utilizado para verificar o estado atual do reposit√≥rio Git. Ele informa quais mudan√ßas foram realizadas, quais arquivos est√£o no estado "staged" (prontos para serem commitados), quais est√£o modificados mas ainda n√£o "staged", e tamb√©m destaca quaisquer arquivos n√£o rastreados

Untracked files / Esses s√£o arquivos que est√£o no diret√≥rio do seu projeto, mas o Git ainda n√£o est√° rastreando. Eles n√£o fazem parte de nenhum commit. Para come√ßar a rastre√°-los, voc√™ precisa adicion√°-los √† √°rea de stage usando git add.

Modified files / S√£o arquivos que foram alterados desde o √∫ltimo commit, mas ainda n√£o foram adicionados √† √°rea de stage. Voc√™ pode prepar√°-los para o commit usando git add ou deix√°-los como est√£o enquanto continua trabalhando neles.

Staged files / Esses arquivos foram adicionados √† √°rea de stage e est√£o prontos para serem inclu√≠dos no pr√≥ximo commit. Um commit grava essas altera√ß√µes no hist√≥rico do reposit√≥rio.

Markdown / Markdown √© uma linguagem de marca√ß√£o leve e simples, criada para formatar texto de forma f√°cil e leg√≠vel. Com ela, voc√™ pode criar documentos estruturados que incluem cabe√ßalhos, listas, tabelas, links, imagens e mais, sem precisar de um editor de texto complexo. O destaque do Markdown √© que o texto ainda √© leg√≠vel sem renderiza√ß√£o, o que facilita tanto a escrita quanto a colabora√ß√£o.

Use o https://readme.so/pt para criar arquivos README decentes com linguagem markdown, um exemplo disso ser√° visto no README do "Primeiro-Projeto-Java", use WINDOWS + . para usar emojis!

git add 'arquivo.txt' / √© usado para adicionar arquivos ou mudan√ßas ao "stage" (√°rea de prepara√ß√£o), deixando-os prontos para serem inclu√≠dos no pr√≥ximo commit. Em resumo, ele coloca suas altera√ß√µes sob rastreamento do Git, git add . adiciona TODOS os arquivos

git commit / √© usado para criar um commit, que registra as altera√ß√µes preparadas na √°rea de stage no hist√≥rico do reposit√≥rio. O -m permite que voc√™ inclua uma mensagem descritiva diretamente no comando, explicando o que foi alterado. √â uma pr√°tica recomendada escrever mensagens claras e informativas para facilitar o entendimento no futuro. git commit -m "Adiciona funcionalidade X ao projeto"

git log / O comando git log √© usado para visualizar o hist√≥rico de commits do reposit√≥rio. Ele lista os commits feitos, mostrando informa√ß√µes como o autor, a data e a mensagem associada a cada commit. √â uma maneira de revisar o progresso do projeto, possui varia√ß√µes que incluem 1 linha ou mais, pesquise!

touch arquivo.txt /  usado principalmente em sistemas baseados em Unix (como Linux e macOS) para criar arquivos vazios ou atualizar a data e hora de modifica√ß√£o de um arquivo existente.

O git reconhece pastas vazias, alguns projetos possuem o arquivo gitkeep.txt dentro de diret√≥rios, isso serve para o git reconhecer os diret√≥rios

Desfazendo altera√ß√µes 

Vamos supor que voc√™ deu git init na pasta errada, era pra ser  /Nova pasta, mas voc√™ colocou /Nova pasta/.git/, para remover isso basta usar
rm - rf .git
e o sistema voltar√° para Nova

Se apagarmos ou alterarmos um arquivo o git status indicar√° a mudan√ßa! caso queiramos reverter ela basta usar
git restore arquivo.md
CUIDADO, ele descarta todas as altera√ß√µes feitas localmente!

Alterar mensagem de commit (que por sua vez aparece no git log)
git commit --amend -m"mensagem nova!"

desfazer commit
git reset --soft 'hashcode'
git reset --mixed 'hashcode'
git reset --hard  'hashcode'

soft / Mant√©m as mudan√ßas na √°rea de stage (prontas para o pr√≥ximo commit). √ötil se voc√™ quer desfazer um commit mas preparar as mesmas altera√ß√µes para um novo commit. Isso desfaz o √∫ltimo commit, mas deixa os arquivos prontos para serem commitados novamente.

mixed / Remove as altera√ß√µes da √°rea de stage, mas as mant√©m nos arquivos de trabalho. √ötil se voc√™ quer fazer ajustes antes de preparar os arquivos novamente. Isso desfaz o commit e remove os arquivos da √°rea de stage, mas mant√©m os arquivos modificados.

hard / Desfaz o commit e descarta completamente as altera√ß√µes nos arquivos. Desfaz o commit e descarta completamente as altera√ß√µes nos arquivos. Isso desfaz o √∫ltimo commit e retorna o reposit√≥rio ao estado anterior, descartando todas as mudan√ßas

git reflog / √© usado para visualizar o hist√≥rico de refer√™ncias de um reposit√≥rio. Ele exibe uma lista de altera√ß√µes feitas nas refer√™ncias do Git (como commits, resets, merges, etc.), permitindo que voc√™ veja e recupere estados anteriores mesmo que tenham sido descartados do log normal. Ele ajuda a rastrear commits "perdidos" ou que foram sobrescritos. Pode ser usado para recuperar altera√ß√µes depois de comandos como git reset --hard. (Cima = mais recente, baixo = menos recente!)

For√ßar altera√ß√µes nos commits pode causar problemas. √â recomendado corrigir os problemas criando um novo commit!

Abrir um reposit√≥rio no github e apertar a tecla '.' vai abrir o projeto em um 'vscode online'!

branches
Ou branch √© uma ramifica√ß√£o do projeto, um ponteiro m√≥vel para um commit no hist√≥rico do reposit√≥rio, quando voc√™ cria uma nova branch a partir de outra existente, a nova se inicia apontando para o mesmo commit da branch que estava quando foi 

commit 0 <-- commit 1 <-- commit 2(branch main)

a branch aponta para o commit 2, mas ele por si s√≥ aponta para o commit anterior
Quando se trabalha com m√∫ltiplas branches em um reposit√≥rio Git, cada branch representa uma linha de desenvolvimento independente. Isso permite que diferentes altera√ß√µes ou funcionalidades sejam desenvolvidas paralelamente sem interferir nas outras. Aqui est√° como funciona, Cada branch tem seu pr√≥prio ponteiro para um commit. Por exemplo:

main (commit 5) <-- commit 4 <-- commit 3
feature-x (commit 6) <-- commit 4 <-- commit 3

Nesse caso, main e feature-x compartilham parte do hist√≥rico, mas depois divergem

git checkout / √© usado principalmente para trocar entre branches ou restaurar arquivos, mas pode ter v√°rias funcionalidades dependendo do contexto. Aqui est√£o os usos mais comuns:

Trocar entre branches: git checkout nome-da-branch

Criar e mudar para uma nova branch: git checkout -b nova-

Restaurar arquivos ao estado de um commit espec√≠fico:
git checkout HEAD arquivo.txt
Isso restaura o arquivo ao √∫ltimo estado commitado.

Restaurar o estado de todo o diret√≥rio:
Caso queira desfazer todas as altera√ß√µes n√£o commitadas
git checkout HEAD .

git merge / O git merge serve para integrar as mudan√ßas de uma branch em outra. Ele preserva o hist√≥rico de commits e une os trabalhos de diferentes desenvolvedores ou funcionalidades.
- Se n√£o houver novos commits na branch de destino, o Fast-forward Merge √© usado: ele simplesmente avan√ßa o ponteiro da branch sem criar um novo commit.
- Caso ambas as branches tenham novos commits, um Merge Commit √© criado para registrar a combina√ß√£o de mudan√ßas.
- Se houver altera√ß√µes conflitantes (ex.: o mesmo arquivo editado em ambas as branches), o Git solicita que voc√™ resolva manualmente antes de concluir o merge.

Exemplo b√°sico:
git checkout main
git merge feature-x

Aqui, a branch feature-x ser√° mesclada na main.

git fetch / O comando git fetch √© usado para baixar atualiza√ß√µes de branches remotas (como commits, tags e metadados) para o reposit√≥rio local, sem alterar as branches locais ou fazer merges. Ele sincroniza o reposit√≥rio local com o remoto, permitindo que voc√™ veja as mudan√ßas antes de aplic√°-las ou integr√°-las. Por exemplo, ap√≥s um git fetch, voc√™ pode comparar as diferen√ßas ou decidir fazer um merge ou rebase manualmente 

Para buscar de uma branch remota espec√≠fica:
git fetch origin nome-da-branch

Para buscar de um reposit√≥rio remoto espec√≠fico (caso voc√™ tenha configurado mais de um):
git fetch nome-do-remoto

Por padr√£o, o git fetch pega todas as atualiza√ß√µes do reposit√≥rio remoto associado (geralmente chamado de origin). Isso n√£o altera sua branch local at√© que voc√™ decida aplicar as mudan√ßas, como com git merge ou git pull.

Se criam uma issue de n√∫mero 1, ao arrumarmos e darmos commit na solu√ß√£o do problema, usamos fix #1 no nome do commit, dessa forma corrigimos a issue de n√∫mero 1


                Sintaxe Java (S√≥ vou anotar o que n√£o sei/lembro)


Cuidado com o CamelCase e etc, essas paradas de nomea√ß√£o de classes, arquivos e etc. Normalmente vari√°veis tipo FINAL, PI, EXEMPLO (toda em ma√≠uscula) indicam vari√°veis que n√£o podem ser alteradas, uma vari√°vel int no estilo ANO_2000 por si s√≥ j√° indica que √© 2000 e n√£o deve ser alteradas

Come√ßo de vari√°veis: letras, $, _ 

express√£o Final em vari√°vel indica que ela n√£o pode ser alterada = constante!

Nomea√ß√£o de pacotes: imagine uma empresa chamada HyperTech, ela possui v√°rios setores, se o setor de comercio for fazer um projeto, seria legal usar esse padr√£o
com.hypertech.'nomeDoProjeto'
com de comercio, e por ai vai, e podemos ter 
com.hypertech.'nomeDoProjeto'.app pra inicializar
com.hypertech.'nomeDoProjeto'.modelo pra por as classes de modelo
com.hypertech.'nomeDoProjeto'.util para guardar os utilit√°rios
com.hypertech.'nomeDoProjeto'.services com regras de neg√≥cio e servi√ßo
A CONVEN√á√ÉO VARIA DE EMPRESA PARA EMPRESA

e por ai vai, os pacotes (pastas) servem para ajudar a organizar os dados!

JavaBeans s√£o componentes reutiliz√°veis da plataforma Java que encapsulam dados e l√≥gica de neg√≥cios, facilitando a comunica√ß√£o entre diferentes partes de uma aplica√ß√£o

Vari√°vel no plural s√≥ se for um arrray de coisas

Fun√ß√µes com nomes de verbo, concluirProcessamento, Somar e por ai vai

float se encerra com F, float pi = 3.14F (f ou F)

JavaDoc √© uma ferramenta utilizada para gerar documenta√ß√£o de c√≥digo em Java com base em coment√°rios no formato especial, facilitando a leitura e compreens√£o das funcionalidades de uma aplica√ß√£o.

pra executar app fora da IDE √© s√≥ achar a pasta bin com o .class que queremos rodar atrav√©s do poweshell ou ms-dos e dar 'java exemplo' sem o .class

Quando voc√™ usa o comando javac para compilar um arquivo-fonte Java (.java), ele gera um arquivo de bytecode Java (.class). Esse arquivo .class cont√©m o c√≥digo que a M√°quina Virtual Java (JVM) pode interpretar e executar.
Se, por exemplo, voc√™ tiver um arquivo Programa.java, ao rodar javac Programa.java, o compilador criar√° Programa.class. Depois, voc√™ pode executar esse programa com java Programa.

- Recebendo Argumentos: O m√©todo main define um par√¢metro String[] args, que √© um array de strings contendo os argumentos passados quando o programa √© executado.
- Atribui√ß√£o de Valores: O programa extrai os valores dos argumentos fornecidos:- args[0]: O primeiro argumento √© armazenado na vari√°vel nome.
- args[1]: O segundo argumento √© armazenado na vari√°vel sobrenome.
- args[2]: O terceiro argumento, que representa a idade, √© convertido para um n√∫mero inteiro (int).
- args[3]: O quarto argumento, que representa a altura, √© convertido para um n√∫mero decimal (double).

- Exibi√ß√£o na Tela: Utilizando System.out.println(), o programa imprime:- Uma sauda√ß√£o com o nome e sobrenome.
- A idade informada.
- A altura informada em cent√≠metros.

EXEMPLO:
public class Programa {
    public static void main(String[] args) {
        // Obtendo os argumentos da linha de comando
        String nome = args[0];
        String sobrenome = args[1];
        int idade = Integer.parseInt(args[2]);
        double altura = Double.parseDouble(args[3]);

        // Exibindo as informa√ß√µes
        System.out.println("Ol√°, me chamo " + nome + " " + sobrenome);
        System.out.println("Tenho " + idade + " anos");
        System.out.println("Minha altura √© " + altura + " cm");
    }
}
(√© de se esperar que tudo seja String, ent√£o por isso o Parse nos outros tipos de dados!)

Se executarmos o programa com os seguintes argumentos:
java Programa Carlos Silva 25 175.5

Ele gerar√° a seguinte sa√≠da:
Ola, me chamo Carlos Silva
Tenho 25 anos
Minha altura √© 175.5 cm

Dentro de um projeto Java no Vscode h√° uma pasta chamada .vscode que cont√©m um arquivo launch.json, l√° podemos definir os argumentos iniciais de execu√ß√£o de um programa!

Erros de programa√ß√£o s√£o denominados bugs e o processo de encontrar e corrigir bugs √© chamado de depura√ß√£o ou debugging.

Existem duas grandes categorias que englobam a natureza do erro:

Erros de Sintaxe:
√â um erro nas regras estabelecidas da linguagem:
Par√™nteses, chaves, colchetes que abrem mas n√£o fecham.
Duas instru√ß√µes sem um ponto-e-v√≠rgula entre elas;
Uma palavra-chave sendo usada numa posi√ß√£o inesperada.

Erros de Sem√¢ntica:
√â um erro na "l√≥gica do c√≥digo", em sua sem√¢ntica, o c√≥digo est√° sintaticamente correto, por√©m n√£o faz o que se esperava dele.
Tentar dividir um n√∫mero por uma String ou por zero.
Atribuir um valor incoerente a um tipo de dado.
Tentar fechar um arquivo que n√£o foi aberto.

Depura√ß√£o/Debugging
Linguagens de alto n√≠vel tornam a depura√ß√£o mais f√°cil, pois fornecem mais ferramentas para identificar erros, como o tratamento de exce√ß√µes.

Os depuradores funcionam assumindo o controle do tempo de execu√ß√£o de um programa e permitindo que voc√™ o observe e controle. Para fazer isso, ele mostra a pilha do programa e permite que voc√™ a atravesse em qualquer dire√ß√£o. Quando voc√™ est√° em um depurador, obt√©m uma imagem mais completa de um quadro de pilha do que quando olha os rastreamentos de pilha em uma mensagem de log.

Pilha de Execu√ß√£o de um Programa Java/Stack Trace
Pilha de Execu√ß√£o:
Toda invoca√ß√£o de m√©todo √© empilhada em uma estrutura de dados que isola a √°rea de mem√≥ria de cada um. Quando um m√©todo termina (retorna), ele volta para o m√©todo que o invocou.

Stack Trace:
√â a matriz onde encontramos a pilha de excecu√ß√£o da exce√ß√£o. Em outras palavras, podemos dizer que o rastreamento da pilha busca (rastreio) para a pr√≥xima linha onde a exce√ß√£o pode surgir.

Lemos a stack trace de baixo para cima!

Tread.dumpStack() imprime o rastreamento da pilha da thread atual no fluxo de erro padr√£o. Isso √© √∫til para depura√ß√£o, pois permite verificar onde uma thread est√° sendo executada em determinado momento.

Breakpoints s√£o essenciais para depura√ß√£o em Java! Eles permitem que voc√™ pause a execu√ß√£o do programa em um ponto espec√≠fico e analise o estado das vari√°veis e do fluxo de execu√ß√£o. Aqui est√£o alguns passos para us√°-los em um ambiente de desenvolvimento como o IntelliJ IDEA ou Eclipse:
- Definir um breakpoint ‚Äì Clique na margem esquerda ao lado de uma linha de c√≥digo onde deseja que a execu√ß√£o pare.
- Executar o programa no modo de depura√ß√£o ‚Äì Use a op√ß√£o de "Debug" ao inv√©s de "Run".
- Inspecionar vari√°veis ‚Äì Quando o programa parar no breakpoint, voc√™ pode examinar valores de vari√°veis no painel de depura√ß√£o.
- Passar pelas linhas ‚Äì Use os comandos "Step Over", "Step Into" e "Step Out" para navegar pelo c√≥digo.
- Modificar valores durante a execu√ß√£o ‚Äì Alguns IDEs permitem alterar valores de vari√°veis no meio da execu√ß√£o para testar diferentes cen√°rios.

 Esses comandos de depura√ß√£o ajudam a navegar pelo c√≥digo em um ambiente de debug. Aqui est√° o que cada um faz:

Step Over (F8 no IntelliJ IDEA, F6 no Eclipse): Avan√ßa para a pr√≥xima linha de c√≥digo sem entrar em m√©todos chamados na linha atual. Se houver uma chamada de m√©todo, ele ser√° executado inteiramente e o depurador passar√° para a pr√≥xima linha no mesmo escopo.

Step Into (F7 no IntelliJ IDEA, F5 no Eclipse): Entra no m√©todo chamado na linha atual, permitindo inspecionar sua execu√ß√£o linha por linha.

Force Step Into (Alt + Shift + F7 no IntelliJ IDEA): Ignora otimiza√ß√µes da IDE e entra at√© mesmo em m√©todos da biblioteca padr√£o ou c√≥digo compilado.

Step Out (Shift + F8 no IntelliJ IDEA, F7 no Eclipse): Sai do m√©todo atual e retorna ao seu chamador, √∫til para concluir rapidamente um m√©todo e voltar ao n√≠vel superior.

Run to Cursor (Alt + F9 no IntelliJ IDEA, Ctrl + R no Eclipse): Continua a execu√ß√£o at√© o ponto onde o cursor est√°, sem a necessidade de um breakpoint.

O Evaluate Expression √© uma ferramenta muito √∫til na depura√ß√£o de c√≥digo Java! Ele permite que voc√™ avalie express√µes ou execute pequenas por√ß√µes de c√≥digo no contexto da execu√ß√£o atual do depurador, sem alterar o c√≥digo-fonte.
Aqui est√£o alguns usos comuns:
- Verificar valores complexos ‚Äì Voc√™ pode inserir qualquer express√£o, como myObject.getSomeValue() e visualizar o resultado sem precisar imprimir no console.
- Modificar valores temporariamente ‚Äì √â poss√≠vel alterar vari√°veis no meio da execu√ß√£o para testar diferentes cen√°rios.
- Testar chamadas de m√©todos ‚Äì Avalie um m√©todo antes de execut√°-lo no c√≥digo principal, garantindo que ele retorna o valor esperado.
- Express√µes booleanas ‚Äì Confirme rapidamente se uma condi√ß√£o if ser√° verdadeira ou falsa antes de prosseguir.

Ao debuggar pode ser necess√°rio inserir dados no console, confirmar  e apertar em step over para seguir a l√≥gica do programa

--
Jeito de aceitar v√≠rgulas e pontos 

Scanner scanner = new Scanner(System.in);
System.out.print("Digite um n√∫mero decimal: ");
String input = scanner.nextLine().replace(",", "."); // L√™ como string e substitui v√≠rgula por ponto

try {
    double numero = Double.parseDouble(input); // Faz o parse para Double
    System.out.println("N√∫mero convertido: " + numero);
} catch (NumberFormatException e) {
    System.out.println("Entrada inv√°lida!");
}

s√≥ pegar o input como string trocar a , por . e dar um parse depois!

Em Java, especialmente em projetos que seguem padr√µes como a arquitetura em camadas (comum em aplica√ß√µes Spring, por exemplo), h√° uma s√©rie de conven√ß√µes para nomear e organizar classes com base em suas responsabilidades. Essas conven√ß√µes ajudam a manter o c√≥digo limpo, organizado e mais f√°cil de manter. Abaixo, explico as principais categorias de classes e suas conven√ß√µes:

1. Modelos (Model / Entity)
Fun√ß√£o: Representam entidades do dom√≠nio do neg√≥cio. Geralmente correspondem a tabelas em um banco de dados.

Conven√ß√µes:

Nome no singular e representativo do conceito de neg√≥cio: User, Product, Order.

Normalmente anotadas com @Entity (em JPA/Hibernate).

Cont√™m atributos com getters/setters, construtores e m√©todos auxiliares (como equals() e hashCode()).

2. Reposit√≥rios (Repository / DAO)
Fun√ß√£o: Respons√°veis pelo acesso a dados (CRUD ‚Äì Create, Read, Update, Delete).

Conven√ß√µes:

Interface com sufixo Repository ou Dao: UserRepository, ProductDao.

Usualmente estendem interfaces como JpaRepository, CrudRepository, etc.

Anotados com @Repository (no Spring).

N√£o cont√™m regras de neg√≥cio, apenas opera√ß√µes de persist√™ncia.

3. Servi√ßos (Service)
Fun√ß√£o: Cont√™m a l√≥gica de neg√≥cio da aplica√ß√£o.

Conven√ß√µes:

Nome com sufixo Service: UserService, PaymentService.

Normalmente anotadas com @Service.

Chamam m√©todos de reposit√≥rios e manipulam entidades.

Implementam regras de neg√≥cio, valida√ß√µes e orquestra√ß√µes de processos.

4. Controladores (Controller)
Fun√ß√£o: Camada de entrada da aplica√ß√£o. Lidam com requisi√ß√µes HTTP.

Conven√ß√µes:

Nome com sufixo Controller: UserController, OrderController.

Anotados com @RestController ou @Controller.

Exp√µem endpoints com m√©todos anotados (@GetMapping, @PostMapping, etc.).

Interagem com os servi√ßos para processar as requisi√ß√µes.

5. DTOs (Data Transfer Objects)
Fun√ß√£o: Objetos usados para transportar dados entre camadas (especialmente entre controller e client).

Conven√ß√µes:

Nome com sufixo DTO: UserDTO, OrderResponseDTO.

N√£o cont√™m l√≥gica de neg√≥cio.

Podem ter valida√ß√µes com @NotNull, @Size, etc.

6. Utilit√°rios e Helpers
Fun√ß√£o: Cont√™m m√©todos auxiliares e utilit√°rios reutiliz√°veis.

Conven√ß√µes:

Nome com sufixo Utils ou Helper: DateUtils, StringHelper.

M√©todos est√°ticos.

N√£o devem depender de estado interno (idealmente stateless).

7. Configura√ß√µes (Configuration)
Fun√ß√£o: Classes que configuram aspectos da aplica√ß√£o, como beans, seguran√ßa, CORS etc.

Conven√ß√µes:

Nome com sufixo Config: SecurityConfig, CorsConfig.

Anotadas com @Configuration, @Enable..., @Bean, etc.

Boas pr√°ticas gerais:
Cada classe deve ter uma √∫nica responsabilidade.

Os nomes devem ser descritivos e consistentes.

Use pacotes separados para cada camada: model, repository, service, controller, etc.

Classes p√∫blicas devem estar em arquivos com o mesmo nome da classe.

Em Java, a cria√ß√£o de pacotes segue conven√ß√µes que visam manter a organiza√ß√£o, legibilidade e modularidade do c√≥digo. Os nomes de pacotes devem ser escritos sempre em letras min√∫sculas, sem acentos ou caracteres especiais, e normalmente iniciam com o dom√≠nio da organiza√ß√£o escrito de forma invertida, como por exemplo com.empresa.projeto. A estrutura dos pacotes costuma refletir a arquitetura da aplica√ß√£o, sendo comum organiz√°-los por responsabilidade, como model para entidades de dom√≠nio, repository para interfaces de acesso a dados, service para regras de neg√≥cio, controller para endpoints REST, dto para objetos de transfer√™ncia de dados e config para configura√ß√µes gerais. Em sistemas maiores, √© recomend√°vel combinar essa estrutura com uma divis√£o por m√≥dulos de neg√≥cio, agrupando as camadas dentro de pacotes como usuario.service, pedido.controller, entre outros, o que facilita a manuten√ß√£o e favorece a escalabilidade. Al√©m disso, no Spring Boot, a classe principal com a anota√ß√£o @SpringBootApplication costuma ficar no pacote raiz da aplica√ß√£o, permitindo o escaneamento autom√°tico de todos os componentes nas subpastas. √â importante evitar nomes gen√©ricos ou pouco descritivos e manter uma hierarquia de pacotes clara, coerente e alinhada com o dom√≠nio da aplica√ß√£o.

basicamente dentro da src √© s√≥ fazer um monte de pacote com cada pacote repleto de clases que variam de assunto para assunto!

Em Java, a visibilidade de classes, m√©todos e atributos √© controlada por modificadores de acesso, que determinam onde esses elementos podem ser acessados. O modificador public permite o acesso de qualquer lugar, inclusive de outras classes em pacotes diferentes. O modificador protected permite acesso dentro do mesmo pacote e tamb√©m por subclasses, mesmo que estejam em pacotes distintos. O modificador default (tamb√©m chamado de package-private), que ocorre quando nenhum modificador √© especificado, permite o acesso apenas dentro do mesmo pacote, mas n√£o fora dele. J√° o modificador private restringe o acesso exclusivamente √† pr√≥pria classe onde o elemento foi declarado. Usar esses n√≠veis de acesso corretamente √© essencial para garantir o encapsulamento e proteger a integridade dos dados e da l√≥gica da aplica√ß√£o.

Em Java, enums (ou tipos enumerados) s√£o tipos especiais de classe usados para representar um conjunto fixo e constante de valores. Eles s√£o ideais quando se deseja trabalhar com um grupo definido de op√ß√µes, como dias da semana, estados de um pedido ou n√≠veis de prioridade. Ao contr√°rio de constantes tradicionais (public static final), enums oferecem mais seguran√ßa e funcionalidades orientadas a objetos, podendo ter atributos, m√©todos e at√© mesmo comportamentos personalizados.

Um enum √© declarado com a palavra-chave enum e cada valor definido dentro dele √© uma inst√¢ncia constante dessa enumera√ß√£o. Por exemplo, um enum DiaSemana pode conter os valores SEGUNDA, TERCA, QUARTA, etc. Al√©m de simples, os enums em Java podem ser estendidos com campos e construtores, permitindo associar valores ou comportamentos espec√≠ficos a cada constante.

Internamente, enums s√£o classes que herdam da classe java.lang.Enum, n√£o podem ser instanciados diretamente (o construtor √© sempre privado) e s√£o imut√°veis. Eles tamb√©m s√£o √∫teis em estruturas de controle como switch e ajudam a deixar o c√≥digo mais leg√≠vel, seguro e expressivo. Ao utilizar enums, evita-se o uso de "valores m√°gicos" e torna-se o c√≥digo mais autodescritivo e menos propenso a erros.

Records em Java s√£o uma forma concisa de criar classes imut√°veis (um tipo especial de classe) que servem principalmente para armazenar dados. Introduzidos oficialmente no Java 16, eles geram automaticamente construtor, m√©todos equals, hashCode e toString, al√©m de acessores (getters) com o nome do campo. N√£o podem herdar de outras classes, mas podem implementar interfaces. S√£o ideais para representar objetos simples, como DTOs, com menos c√≥digo, em record todo atributo declarado √© privado, lemos seus atributos atrav√©s de m√©todos, √© poss√≠vel ter um constrututor adicional, mas precisamos chamar o construtor default do record para isso, podemos passar valores padr√µes atrav√©s dele ent√£o:
    Se por o construtor default receber um nome e idade, podemos colocar o construtor default como super do construtor adicional e declarar a idade como '1', ent√£o todo objeto criado com o modelo do construtor secund√°rio, isso √©, s√≥ com nome e sem a idade, vai ficar no padr√£o "fulano" 1, "beltrano" 1, e por ai vai! <- SOBRECARGA!

public record Pessoa(String nome, int idade) {}

Nesse exemplo:

nome e idade s√£o campos de inst√¢ncia (n√£o est√°ticos)
S√£o implicitamente private e final
Voc√™ acessa seus valores pelos m√©todos nome() e idade()


Uma classe sealed em Java √© uma classe que pode ser estendida somente por classes espec√≠ficas, definidas explicitamente usando a palavra-chave permits. Isso permite um controle mais rigoroso sobre a heran√ßa, garantindo que a classe n√£o seja estendida por qualquer outra classe, apenas pelas que forem mencionadas.

Caracter√≠sticas:
sealed: Restringe as subclasses permitidas.
permits: Lista as classes que podem estender a classe sealed.
Subclasses podem ser:
final: N√£o podem ser estendidas.
non-sealed: Permitem outras classes para estend√™-las.
sealed: Permite outras classes, mas s√≥ com permiss√µes expl√≠citas.

public sealed class Animal permits Dog, Cat { ... }
public final class Dog extends Animal { ... }
public non-sealed class Cat extends Animal { ... }

Essa abordagem oferece controle e seguran√ßa sobre a heran√ßa e pode ser usada para otimiza√ß√µes de desempenho no compilador.

                Collections

Uma cole√ß√£o (collection) √© uma estrutura de dados que serve para agrupar muitos elementos em uma √∫nica unidade (vari√°vel); estes elementos precisam ser objetos (SEM TIPOS PRIMITIVOS!).
Uma Collection pode ter cole√ß√µes homog√™neas e heterog√™neas, normalmente utilizamos cole√ß√µes homog√™neas de um tipo espec√≠fico.
O n√∫cleo principal das cole√ß√µes √© formado pelas interfaces da figura abaixo; essas interfaces permitem manipular a cole√ß√£o independentemente do n√≠vel de detalhe que elas representam.
Temos quatro grandes tipos de cole√ß√µes: List (lista), Set (conjunto), Queue (fila) e Map (mapa). A partir dessas interfaces, temos muitas subclasses concretas que implementam v√°rias formas diferentes de se trabalhar com cada cole√ß√£o.

Todas as interfaces e classes s√£o encontradas dentro do pacote (package) java.util.
Embora a interface Map n√£o seja filha direta da interface Collection, ela tamb√©m √© considerada uma cole√ß√£o devido √† sua fun√ß√£o.

https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collection.html <- SUMARIO DE M√âTODOS!

https://github.com/cami-la/collections-java-api-2023/tree/master/src/main/java <- RESUM√ÉO PRA CONSULTA POSTERIOR

Generics permitem iterar sobre listas de forma mais simples sem fazer cast!

Maps com generics permitem declarar estritamente o tipo de dado e mais uma vez permitem itera√ß√µes sem cast!

Em Java, Comparable e Comparator s√£o duas interfaces utilizadas para realizar ordena√ß√µes de objetos.

A interface Comparable define a ordem natural de uma classe. Quando uma classe implementa Comparable, ela precisa sobrescrever o m√©todo compareTo(), que define como os objetos dessa classe ser√£o comparados entre si. Isso √© √∫til quando a pr√≥pria classe tem uma forma principal e √∫nica de ser ordenada ‚Äî por exemplo, ordenar produtos pelo pre√ßo.

J√° a interface Comparator √© usada quando queremos definir v√°rias maneiras diferentes de comparar objetos. Ela √© implementada em uma classe separada (ou por uma express√£o lambda), que sobrescreve o m√©todo compare(). Isso √© √∫til quando precisamos ordenar os mesmos objetos de formas diferentes, como por nome, data ou outro crit√©rio espec√≠fico.

A principal diferen√ßa entre elas √© que Comparable define a ordena√ß√£o dentro do pr√≥prio objeto, enquanto Comparator permite definir ordena√ß√µes externas e m√∫ltiplas, oferecendo maior flexibilidade.

                Stream API
√© uma ferramenta que permite processar cole√ß√µes de forma funcional, declarativa e concisa. Ela facilita opera√ß√µes como filtrar, mapear, ordenar, agrupar e reduzir elementos de listas, arrays e outras fontes de dados.

bla bla bla 

DRAW.IO PRA FAZER DIAGRAMAS!!!!!

                SpringBoot

Framework opensource recheado de m√≥dulos para diferentes coisas como web dev, bancos e dados, testes unitarios e etc.

invers√£o de controle √© redirecionar o fluxo de execuc√£o do c√≥digo retirando parcialmente o controle sobre ele e delegando-o para um container, pra minimizar o acoplamento do 

inje√ß√£o de depend√™ncias √© um padr√£o de desenvolvimento com a finalidade de manter o baixo nivel de acoplamento entre modulos de um sistema

bens √© um objeto instanciado (Criado) montado e gerenciado por um container atraves do principio da invers√£o de controle

singleton, o container do spring IOC (inversao de controle) define apenas uma instancia do objeto

prototype, ser√° criado um novo objeto a cada solicita√ß√£o ao container

um bean √© criado para cada requisi√ß√£o http, e exitir√° enquanto a requisi√ß√£o estiver em execu√ß√£o

http session, um bean ser√° criado para a sess√£o de usu√°rio, precisamos acessar a mesma solicita√ß√£o duas vezes para testar os escopos especificos da web

http global, Ou Application Scope cria um bean para o ciclo de vida do contexto da aplica√ß√£o

autowired Uma anota√ß√£o (indica√ß√£o) onde dever√° ocorrer uma inje√ß√£o autom√°tica de depend√™ncia.

byName: √â buscado um m√©todo set que corresponde ao nome do Bean.

byType: √â considerado o tipo da classe para inclus√£o do Bean.

byConstrutor: Usamos o construtor para incluir a depend√™ncia.

Starters s√£o pacotes prontos (depend√™ncias) que o Spring Boot oferece para facilitar a inclus√£o de funcionalidades na sua aplica√ß√£o. Eles agrupam v√°rias bibliotecas comuns em um s√≥ lugar, para que voc√™ n√£o precise configurar tudo manualmente.

Principais Starters do Spring Boot:
Starter	Para que serve
spring-boot-starter-web	Aplica√ß√µes web, APIs REST
spring-boot-starter-data-jpa	Integra√ß√£o com banco de dados usando JPA/Hibernate
spring-boot-starter-security	Seguran√ßa e autentica√ß√£o
spring-boot-starter-test	Testes unit√°rios e de integra√ß√£o
spring-boot-starter-thymeleaf	Templates HTML usando Thymeleaf
spring-boot-starter-actuator	Monitoramento da aplica√ß√£o em tempo real
spring-boot-starter-validation	Valida√ß√µes com Bean Validation (JSR-380, ex: @NotNull, @Email)
data-mongodb: Intera√ß√£o com banco de dados mongoDB

Primeiros passos:

Criando um projeto com initializr (Spring initializr na web)
monta como quiser e bota as depend√™ncias, ele vai baixar um .zip

importando o projeto maven no vscode
tecnicamente ele baixa todas depend√™ncias

Conhecendo a estrutura spring boot
mesmo padr√£o do java, pom.xml tem informa√ß√µes sobre o projeto
src/main/resources/application.proprieties √© onde botamos informa√ß√µes e configura√ß√µes sobre portas de servidores e etc, bancos de dados e por ai vai

Bean e CommandLineRunner


"new" n√£o existe em springboot, √© errado instanciar classes dessa forma, ent√£o nada de 
Pessoa pessoa = new Pessoa("Carlos");

Nosso m√©todo main, ou app.java precisa implementar uma interface chamada "CommandLineRunner" e seus m√©todos, cima dele e logo abaixo das importa√ß√µes devemos ditar que ele ir√° usar componentes, para isso colocamos @Component, note que precisamos fazer o mesmo nas classes que queremos instanciar! 
E abaixo da classe instanciamos a classe dessa forma:
@Autowired
private Pessoa pessoa;
 


Use @Component quando voc√™ quer que o Spring crie e gerencie uma inst√¢ncia de uma classe automaticamente.
Onde usar:
Direto em cima de uma classe que voc√™ criou.
Quando quer que o Spring descubra a classe automaticamente via component scanning.

Exemplo
@Component
public class MeuServico {
    public void executar() {
        System.out.println("Executando servi√ßo...");
    }
}



Use @Bean quando voc√™ quer registrar manualmente um objeto como bean no Spring. √â usado dentro de uma classe anotada com @Configuration.
Onde usar:
Em m√©todos de f√°brica dentro de classes de configura√ß√£o.
Quando precisa criar inst√¢ncias de classes de terceiros (que n√£o t√™m anota√ß√µes Spring).
Quando precisa de l√≥gica personalizada para criar o bean.

Exemplo
@Configuration
public class ConfiguracaoApp {

    @Bean
    public MeuServico meuServico() {
        return new MeuServico();
    }
}


üß† Diferen√ßa pr√°tica
Caracter√≠stica |	@Component |	@Bean
Onde usar |	Em uma classe |	Em um m√©todo
Tipo de controle |	Spring instancia automaticamente |	Voc√™ instancia manualmente
Flexibilidade |	Menos flex√≠vel |	Mais controle na cria√ß√£o do objeto
Ideal para	Suas pr√≥prias classes |	Bibliotecas de terceiros, ou l√≥gica customizada

Quando usar cada um?
Situa√ß√£o |	Use
Classe √© sua e simples	@Component
Classe precisa ser configurada com par√¢metros	@Bean
Classe vem de uma biblioteca externa (sem anota√ß√µes)	@Bean
Voc√™ quer controle sobre como o objeto √© criado	@Bean

√â uma conven√ß√£o criar uma classe "beans" para agrupar os beans!
as vezes precisamos por @Configuration acima na classe mencionada para n√£o ter erro na inje√ß√£o de depend√™ncias

Se tem acesso ao c√≥digo fonte use Components, do contr√°rio, Beans


O que √© escopo (Scope )de um bean?
No Spring, um bean √© um objeto gerenciado pelo container da aplica√ß√£o. O escopo define quantas inst√¢ncias desse objeto ser√£o criadas e como elas ser√£o entregues quando forem requisitadas.


 Singleton (padr√£o do Spring)
O que √©?
√â o escopo padr√£o no Spring. Significa que o Spring cria apenas uma √∫nica inst√¢ncia do bean durante toda a vida da aplica√ß√£o.

Quando usar?
Quando o bean n√£o precisa ser recriado a cada uso, ou seja, pode ser compartilhado por toda a aplica√ß√£o.

Vantagens:
Consome menos mem√≥ria.
Ideal para servi√ßos ou reposit√≥rios que mant√™m estado compartilhado ou s√£o stateless (sem estado).

Exemplo:
@Component
public class MeuServico {
    // ser√° criada apenas uma inst√¢ncia de MeuServico
}


Prototype
O que √©?
Um bean com escopo prototype ser√° criado novamente toda vez que for solicitado ao Spring.

Quando usar?
Quando voc√™ precisa de uma nova inst√¢ncia para cada uso ‚Äî por exemplo, quando o bean tem estado pr√≥prio e n√£o pode ser compartilhado.

Vantagens:
√ötil para objetos com estado tempor√°rio ou dados din√¢micos.
Evita efeitos colaterais entre usu√°rios ou requisi√ß√µes.

Exemplo:
@Scope("prototype")
@Component
public class Pedido {
    // cada vez que for requisitado, um novo Pedido ser√° criado
}


No Spring Boot, o arquivo application.properties serve para guardar configura√ß√µes da aplica√ß√£o, como nomes, URLs ou chaves. A anota√ß√£o @Value √© usada para ler essas configura√ß√µes e injet√°-las dentro do c√≥digo.

Por exemplo, se voc√™ tiver app.nome=MinhaApp no application.properties, pode usar @Value("${app.nome}") em uma classe para acessar esse valor. Isso ajuda a manter o c√≥digo limpo, separado da configura√ß√£o, e facilita a troca de valores conforme o ambiente (dev, prod, etc.).

Se a propriedade n√£o for encontrada, a aplica√ß√£o pode dar erro, mas √© poss√≠vel definir um valor padr√£o assim: @Value("${app.autor:Desconhecido}"). com dois pontos :

@ConfigurationProperties √© uma forma do Spring de carregar v√°rias configura√ß√µes de uma vez em uma classe, ao inv√©s de usar v√°rios @Value. Ela √© usada para mapear um grupo de propriedades do application.properties para atributos de uma classe Java.

Em vez de injetar um por um com @Value, voc√™ define uma classe com atributos e o Spring preenche tudo de forma autom√°tica com base no prefixo configurado.
Por exemplo, se voc√™ tem propriedades como app.nome e app.versao, pode criar uma classe AppProperties, usar @ConfigurationProperties(prefix = "app"), e o Spring liga tudo automaticamente.
√â mais organizado, reutiliz√°vel e limpo, principalmente quando h√° muitas configura√ß√µes relacionadas.


A anota√ß√£o @ConfigurationProperties(prefix = "algum.prefixo") √© usada no Spring para mapear automaticamente propriedades definidas no application.properties (ou application.yml) para os campos de uma classe Java, com base em um prefixo comum.

Exemplo pr√°tico em texto:
Se no application.properties voc√™ tem:
app.nome=MinhaApp
app.versao=1.0


Voc√™ pode criar uma classe assim:
@Configuration
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    private String nome;
    private String versao;
    // getters e setters
}
O Spring vai preencher nome e versao automaticamente com os valores definidos

A classe precisa estar registrada como bean (com @Component ou usando @EnableConfigurationProperties).
Requer m√©todos get e set (ou uso de @Data do Lombok, por exemplo).

No contexto do Spring Boot, os conceitos de ORM e JPA s√£o fundamentais para facilitar o trabalho com bancos de dados de forma orientada a objetos.

ORM, sigla para Object-Relational Mapping (Mapeamento Objeto-Relacional), √© uma t√©cnica que permite mapear objetos do c√≥digo (como classes Java) para tabelas de um banco de dados relacional. Isso significa que, ao inv√©s de escrever comandos SQL diretamente, o desenvolvedor pode manipular dados por meio de objetos Java, enquanto o ORM cuida automaticamente da convers√£o entre esses objetos e os dados no banco.

JPA, ou Java Persistence API, √© uma especifica√ß√£o da linguagem Java que define como os objetos Java devem ser armazenados em bancos de dados relacionais. Ela fornece um conjunto de regras e anota√ß√µes para indicar como as classes devem ser persistidas, mas n√£o realiza essa persist√™ncia diretamente ‚Äî quem faz isso s√£o implementa√ß√µes da JPA, como o Hibernate, que √© a mais usada com Spring Boot.

No Spring Boot, o uso de JPA √© geralmente feito por meio do Spring Data JPA, que integra JPA e Hibernate de forma automatizada. Com ele, √© poss√≠vel mapear uma classe Java para uma tabela do banco com a anota√ß√£o @Entity, definir um identificador com @Id, e criar reposit√≥rios que estendem interfaces como JpaRepository, permitindo acessar e manipular dados com m√©todos prontos, como save, findAll, delete, entre outros.

Al√©m disso, o JPA tamb√©m permite definir os relacionamentos entre entidades, como um-para-muitos ou muitos-para-um, utilizando anota√ß√µes como @OneToMany e @ManyToOne.

Em resumo, o ORM √© a t√©cnica que permite a convers√£o entre objetos Java e tabelas do banco de dados, e a JPA √© a especifica√ß√£o Java que define como essa t√©cnica deve ser aplicada. No Spring Boot, essas ferramentas trabalham juntas para tornar o acesso ao banco de dados mais simples, limpo e orientado a objetos.

A Java Persistence API (JPA) √© uma especifica√ß√£o da plataforma Java que define como os dados de objetos Java devem ser persistidos em bancos de dados relacionais. Ela faz parte da Jakarta EE (anteriormente Java EE) e fornece uma forma padronizada de lidar com a persist√™ncia de dados. JPA √© amplamente utilizada em aplica√ß√µes corporativas e √© a base da persist√™ncia de dados em frameworks como o Spring Boot, que geralmente a utiliza em conjunto com a implementa√ß√£o Hibernate.

Um dos principais recursos da JPA s√£o os mapeamentos entre classes Java e tabelas do banco de dados. Esses mapeamentos s√£o feitos por meio de anota√ß√µes nas classes. Por exemplo, a anota√ß√£o @Entity indica que a classe √© uma entidade persistente e deve ser mapeada para uma tabela. A anota√ß√£o @Table pode ser usada para especificar o nome da tabela correspondente. Cada atributo da classe representa uma coluna da tabela, e pode ser configurado com anota√ß√µes como @Column, @Id (para a chave prim√°ria), @GeneratedValue (para gera√ß√£o autom√°tica de IDs), entre outras.

Al√©m disso, JPA suporta relacionamentos entre entidades, como um-para-um (@OneToOne), um-para-muitos (@OneToMany), muitos-para-um (@ManyToOne) e muitos-para-muitos (@ManyToMany). Esses relacionamentos representam liga√ß√µes entre tabelas e s√£o essenciais para modelar estruturas de dados complexas no banco relacional.

No cora√ß√£o da JPA est√° o EntityManager, que √© a interface principal para realizar opera√ß√µes de persist√™ncia. Ele √© respons√°vel por gerenciar o ciclo de vida das entidades, incluindo opera√ß√µes como salvar, atualizar, remover e buscar objetos no banco de dados. Por exemplo, para persistir um objeto, utiliza-se o m√©todo persist, e para buscar um objeto pelo seu ID, usa-se o m√©todo find. O EntityManager tamb√©m fornece suporte para consultas com JPQL (Java Persistence Query Language), que √© uma linguagem de consulta orientada a objetos, similar ao SQL, mas operando sobre entidades ao inv√©s de tabelas diretamente.

O EntityManager geralmente √© injetado via anota√ß√£o @PersistenceContext, e seu ciclo de vida √© gerenciado pelo container (no caso de aplica√ß√µes Java EE) ou pelo Spring, quando usado com Spring Boot. Um exemplo b√°sico de uso seria:

@PersistenceContext
private EntityManager entityManager;


Com ele, pode-se realizar opera√ß√µes como:

entityManager.persist(cliente);
Cliente encontrado = entityManager.find(Cliente.class, 1L);
entityManager.remove(encontrado);


Em resumo, a JPA padroniza o mapeamento objeto-relacional em Java, permitindo que desenvolvedores trabalhem com dados de maneira orientada a objetos. Seus mapeamentos facilitam a transforma√ß√£o de classes em tabelas e seus campos em colunas, enquanto o EntityManager √© o componente central para interagir com o banco de dados, controlando o ciclo de vida das entidades e fornecendo uma interface poderosa para opera√ß√µes de persist√™ncia.

Spring Data JPA √© um projeto do ecossistema Spring que facilita o uso da Java Persistence API (JPA) em aplica√ß√µes Spring, especialmente com o Spring Boot. Ele abstrai grande parte da complexidade do acesso a dados, fornecendo uma forma simples, poderosa e declarativa de interagir com bancos de dados relacionais.

Na pr√°tica, o Spring Data JPA permite que voc√™ trabalhe com reposit√≥rios de dados (interfaces) sem precisar implementar manualmente consultas ou l√≥gica de persist√™ncia. Ele se integra com implementa√ß√µes de JPA como o Hibernate, que √© a mais comum, e gerencia automaticamente o EntityManager, sess√µes e transa√ß√µes.

O principal recurso do Spring Data JPA √© a cria√ß√£o autom√°tica de m√©todos de acesso a dados com base na nomenclatura dos m√©todos. Por exemplo, se voc√™ tiver uma entidade chamada Cliente, basta criar uma interface como ClienteRepository estendendo JpaRepository, e poder√° utilizar m√©todos prontos como findAll(), findById(), save(), delete(), entre outros, sem escrever nenhuma linha de SQL.

Al√©m dos m√©todos prontos, voc√™ pode criar m√©todos personalizados com base em nomes descritivos, como findByNome(String nome) ou findByEmailAndStatus(String email, String status). O Spring interpreta esses nomes e gera automaticamente as consultas correspondentes.

O Spring Data JPA tamb√©m permite escrever consultas mais complexas usando JPQL, SQL nativo, ou a API de Specification, que fornece crit√©rios din√¢micos de consulta. Essas consultas podem ser anotadas com @Query nas interfaces de reposit√≥rio.

Outra vantagem √© o suporte a pagina√ß√£o e ordena√ß√£o, que pode ser feito facilmente usando os tipos Pageable e Sort, permitindo que se implementem APIs REST com controle total sobre o volume e a ordem dos dados retornados.

Por fim, o Spring Data JPA se integra muito bem ao restante do ecossistema Spring, como Spring Security, Spring Web e Spring Boot, simplificando drasticamente o desenvolvimento de aplica√ß√µes robustas e escal√°veis, ELE √â UMA DEPEND√™NCIA QUE VOC√ä COLOCA NO Spring initializr, temos que por tamb√©m as depend√™ncias do banco de dados que vamos utilizar

Para configurar o PostgreSQL como banco de dados em um projeto Spring Boot com Spring Data JPA, √© necess√°rio adicionar a depend√™ncia do driver do PostgreSQL e definir corretamente as propriedades de conex√£o no arquivo de configura√ß√£o da aplica√ß√£o (application.properties ou application.yml).

No Maven, a depend√™ncia do PostgreSQL deve ser adicionada ao arquivo pom.xml da seguinte forma:
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>

Caso esteja usando Gradle, a linha correspondente no build.gradle seria:
runtimeOnly 'org.postgresql:postgresql'

Depois disso, o pr√≥ximo passo √© configurar a conex√£o no arquivo application.properties. As propriedades b√°sicas incluem:
spring.datasource.url=jdbc:postgresql://localhost:5432/nomedobanco
spring.datasource.username=seu_usuario
spring.datasource.password=sua_senha
spring.datasource.driver-class-name=org.postgresql.Driver

spring.jpa.hibernate.ddl-auto=update
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.show-sql=true


Essas configura√ß√µes definem a URL de conex√£o JDBC com o PostgreSQL (onde localhost √© o host, 5432 √© a porta padr√£o e nomedobanco √© o nome do seu banco de dados), al√©m do nome de usu√°rio e senha. O hibernate.ddl-auto=update faz com que o Hibernate atualize automaticamente o schema do banco conforme as entidades, √∫til durante o desenvolvimento. A propriedade show-sql=true exibe as queries SQL no console, o que ajuda na depura√ß√£o.

Al√©m disso, √© importante garantir que o servi√ßo do PostgreSQL esteja rodando e que o banco e as credenciais especificadas existam. Para projetos maiores ou ambientes de produ√ß√£o, outras propriedades como connection pool, caching, e logging podem ser ajustadas.

O JpaRepository √© uma interface do Spring Data JPA que fornece um conjunto completo de m√©todos prontos para realizar opera√ß√µes de persist√™ncia em entidades JPA. Ela faz parte da infraestrutura que facilita a integra√ß√£o entre o Spring Boot e a JPA, evitando a necessidade de escrever implementa√ß√µes manuais de acesso a dados.

Ao estender a interface JpaRepository, o desenvolvedor herda m√©todos para opera√ß√µes comuns como salvar (save), buscar por ID (findById), buscar todos (findAll), deletar (delete), entre outros. Isso permite focar na l√≥gica de neg√≥cio, sem a necessidade de escrever c√≥digo repetitivo de acesso a banco.

Por exemplo, em vez de criar uma implementa√ß√£o para um reposit√≥rio de clientes, basta criar uma interface como ClienteRepository estendendo JpaRepository<Cliente, Long>, onde Cliente √© a entidade e Long √© o tipo do ID. Com isso, o Spring gera automaticamente a implementa√ß√£o dos m√©todos de CRUD.

Al√©m dos m√©todos herdados, o JpaRepository permite definir m√©todos personalizados com base na nomenclatura. Por exemplo, um m√©todo findByNome(String nome) √© interpretado automaticamente pelo Spring como uma consulta para buscar clientes pelo campo nome.

O JpaRepository tamb√©m oferece suporte a pagina√ß√£o, ordena√ß√£o, proje√ß√µes, e consultas personalizadas usando anota√ß√µes como @Query (com JPQL ou SQL nativo).

Por estar integrado com o Spring Boot, o uso de JpaRepository tamb√©m se beneficia da inje√ß√£o de depend√™ncia e da configura√ß√£o autom√°tica de componentes, tornando o desenvolvimento r√°pido, organizado e aderente √†s boas pr√°ticas do Spring.


REST e RESTful:

REST (Representational State Transfer) √© um estilo de arquitetura de software para sistemas distribu√≠dos, geralmente usado na constru√ß√£o de APIs. Ele se baseia em um conjunto de restri√ß√µes, como a utiliza√ß√£o de HTTP para comunica√ß√£o e a utiliza√ß√£o de m√©todos como GET, POST, PUT e DELETE. O REST enfatiza a simplicidade e a escalabilidade.

RESTful refere-se √† implementa√ß√£o de uma API que segue as restri√ß√µes e princ√≠pios do REST. Isso significa que a API deve ser baseada em recursos (URLs) e deve utilizar os m√©todos HTTP de forma adequada.

Controllers:

Controllers (ou controladores) s√£o componentes essenciais na arquitetura de software, particularmente no padr√£o MVC (Model-View-Controller). Em APIs RESTful, os controladores s√£o respons√°veis por manipular as requisi√ß√µes HTTP, interagir com os modelos de dados (como banco de dados) e retornar as respostas apropriadas ao cliente. Os controladores mapeiam as rotas de requisi√ß√£o para as fun√ß√µes espec√≠ficas que devem ser executadas.

Swagger:

Swagger √© uma ferramenta que permite documentar, testar e visualizar APIs de forma interativa. Ela gera documenta√ß√£o interativa de uma API RESTful e permite que os desenvolvedores e usu√°rios interajam diretamente com a API atrav√©s de uma interface gr√°fica. Com o Swagger, √© poss√≠vel ver as opera√ß√µes dispon√≠veis, os par√¢metros necess√°rios e at√© testar as chamadas da API de maneira f√°cil.

Exception Handler:

Exception Handler (ou manipulador de exce√ß√µes) √© um mecanismo utilizado em APIs para tratar erros de maneira adequada. Ele captura exce√ß√µes (erros) que ocorrem durante o processamento das requisi√ß√µes e fornece respostas apropriadas, como mensagens de erro ou c√≥digos de status HTTP (por exemplo, 404 para "n√£o encontrado" ou 500 para "erro interno do servidor"). O tratamento adequado de exce√ß√µes √© fundamental para garantir que a API seja robusta e f√°cil de usar, fornecendo informa√ß√µes claras sobre o que deu errado.

Esses s√£o conceitos fundamentais no desenvolvimento de APIs modernas, especialmente quando se busca construir sistemas escal√°veis, robustos e bem documentados.
