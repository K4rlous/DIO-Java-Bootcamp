BootCamp Bradesco 2025

                Introdução à plataforma Java:

Pilares POO - Classes e objetos, Encapsulamento, Abstração, Herança, Polimorfismo

Código -> Bytecode -> ....

Bytecode e JVM tornam o Java 

A JVM transforma o Bytecode em algoritmo que será interpretado pelo sistema!

WORA (Write once, run anywhere)

Robustez: Gerenciamento de memória forte, coleta de lixo, tratamento de exceção e mecanismos de verificação de tipo de dados

Segurança: Recursos de criptografia e descriptografia

Java compila gerando Bytecode e a JVM (Java Virtual Machine) interpreta o arquivo em Bytecode durante a execução

Thread = subprocesso leve e independente de um programa em execução, Java é multithread logo possui vários threads sendo executados simultaneamente

Java = Cidade de origem de um tipo de café 


                Ambiente de desenvolvimento Java

Funções com autocomplete e inteliSense, formatação de palavras e blocos de Código, análises de erro de sintaxe, compilação de programas e depuração (acompanhamento) de execução do programa

IDeS principais: Eclipse, Netbeans, Intellij, Vscode

Maven = Umas das formas de empacotamento de projetos em java, ferramenta de automação de compilação também usada para construir e gerenciar projetos escritos em C#, Ruby, Scala, e outras linguagens

Snippet = Termo de programação para uma pequena região de código-fonte reutilizável, código de máquina ou texto. Normalmente, estas são unidades operacionais formalmente definidas para serem incorporadas em módulos de programação maiores.

Instalar o JDK (Vscode automotiza com o Java Coding pack, que inclui o Vscode, JDK e extensões úteis e essenciais!) ele também pode ser usado para atualizar um Vscode sem o JDK e as extensões!

O Eclipse possui versões (packages) para desenvolvimento Java puro e uma versão específica para desenvolvimento Web! a escolha de diretório no Eclipse é meio chata, mas uma convenção legal é: c/dev/ws/'trabalho' / dev de desenvolvimento, ws de workspace! e c/dev/projetos/'projeto' para projetos!


JDK PATH = c://Arquivos de Programas / Java / JDK (várias versões?)

No CMD 'java -version' retorna a versão atual do Java instalado

Todo projeto Java sem um sistema de gerenciamento de projetos (como o Maven) possui pastas como 'lib', 'src' e arquivos que documentam a estrutura do projeto como um todo como o 'readme' que inclui informações sobre o projeto

A integração do Vscode com o Github, permite usar o Gitclone no Vscode para clonar nossos repositórios, CTRL + SHIFT + P para criar novos projetos Java e ver outras funcionalidades!

JRE (Java Runtime Enviroment) é necessário apenas para rodar código Java, e não desenvolver!

As quatro principais plataformas de desenvolvimento Java são: 
Java SE (Java Platform, Standard Edition)
Java EE (Java Platform, Enterprise Edition)
Java ME (Java Platform, Micro Edition)
Java FX

                Versionamento de Código com Git e GitHub 

Controlam as versões de um arquivo ao longo do tempo, registram histórico de atualizações do arquivo, gerenciam quais foram as alterações, datas, autores e etc. Organização, Controle e Segurança

Tipos: VCS Centralizado (CVCS) = Centralizam os dados em um servidor <- se ficar fora do ar o projeto fica inacessível, se houver perca de dados (e tu não tiver backup) todo o projeto é perdido

VCS Distribuido (DVCS) = Clona o repositório incluindo o histórico de versões, cada clone é como um backup, possibilita fluxo de trabalho flexivel, possibilita trabalhar sem rede de internet!

O Git é um sistema de controle de versão distribuído amplamente usado por desenvolvedores para gerenciar projetos de software. Ele permite que você acompanhe mudanças no código, trabalhe em equipe simultaneamente e volte a versões anteriores quando necessário. O Git organiza o histórico de alterações em "commits", facilitando o rastreamento e a colaboração eficiente. Com ele, você pode criar ramificações (branches) para desenvolver novos recursos ou corrigir bugs sem afetar o código principal. 

git clone -> Clona um repositório git existente para um novo diretório local
git commit -> Salva as alterações no repositório
git pull -> Puxa as alterações do repositório remoto para o local (busca e mescla)
git push -> Empurra as alterações do repositório local para o remoto
commit -> pull -> push
git --version no CMD pra ver a versão do Git

GitBash (Aberto em algum diretório) permite usar comandos para configurar o Git / CTRL + L limpa o terminal!
git config - permite ver alterações, tais como alterar as variáveis de configuração

Como todos os nossos repositórios tem de estar em nosso nome as alterações devem estar em escopo global

git config --global user.name "Fulano" / Definir o nome do usuário
git config --global user.email fulano@gmail.com / Definir o email do usuário
Ambos comandos sem argumentos (nome ou email) vão retornar os nomes e emails respectivamente usados

Esses dados serão vinculados aos commits, mudar o nome ou email não irá alterar commits já feitos!

git config init.defaultBranch / Retorna o nome da branch
git config --global init.defaultBranch algo / Muda o nome da branch para 'algo'

git config --global --list / Lista todas as configurações globais (sem o global ia mostrar tudo)

O Github é uma plataforma de hospedagem de código para controle de versão com Git e colaboração

(Ela fez o login no Git com o Token do Github??)
Nós usamos SSH para logar (Secure Shell) OU NÃO?

git config --global credential.helper store / Salva as credênciais 
git config --global credential.helper cache / Salva temporariamente (util se dividir a máquina)
git config --global credential.helper / Mostra como está salvando

git config --global --show-origin credential.helper / Mostra onde as credênciais estão salvas e o 'modo' dela

Criando e Clonando Repositórios

Existem duas formas de obter um repositório Git na sua máquina: 1. Transformando um diretório local que não está sob controle de versão, num repositório Git; 2. Clonando um repositório Git existente

Comandos do GitBash
1°
mkdir repo-local / Cria o diretório 'repo-local'
cd repo-local / Muda o diretório para 'repo-local'
git init / Transforma o diretório atual em um repositório git (main)
cd .git / Muda o diretório para 'git' (git_dir)
ls / Lista os arquivos (entre eles há um arquivo de configurações)
cat config / Mostra os dados do arquivo de configurações mencionado.

2°
Copia-se o código https do repositório no Github
git clone 'url' / Copia o repositório da url
git clone 'url' 'nome' / Copia o repositório da url e muda o nome da pasta para 'nome'


git remote -v / Mostra os repositórios remotos aos quais está vinculado
git remote add 'nome' 'url do repositório ao qual queremos vincular' (padrão deixar o nome 'origin') / Conecta o repositório local com um repositório remoto

git clone 'url' --branch 'nome-da-branch' --single-branch / Clona apenas a branch escolhida pelo nome, se não passar o nome ele clona a principal seja a 'main' ou a 'master'

git status / é utilizado para verificar o estado atual do repositório Git. Ele informa quais mudanças foram realizadas, quais arquivos estão no estado "staged" (prontos para serem commitados), quais estão modificados mas ainda não "staged", e também destaca quaisquer arquivos não rastreados

Untracked files / Esses são arquivos que estão no diretório do seu projeto, mas o Git ainda não está rastreando. Eles não fazem parte de nenhum commit. Para começar a rastreá-los, você precisa adicioná-los à área de stage usando git add.

Modified files / São arquivos que foram alterados desde o último commit, mas ainda não foram adicionados à área de stage. Você pode prepará-los para o commit usando git add ou deixá-los como estão enquanto continua trabalhando neles.

Staged files / Esses arquivos foram adicionados à área de stage e estão prontos para serem incluídos no próximo commit. Um commit grava essas alterações no histórico do repositório.

Markdown / Markdown é uma linguagem de marcação leve e simples, criada para formatar texto de forma fácil e legível. Com ela, você pode criar documentos estruturados que incluem cabeçalhos, listas, tabelas, links, imagens e mais, sem precisar de um editor de texto complexo. O destaque do Markdown é que o texto ainda é legível sem renderização, o que facilita tanto a escrita quanto a colaboração.

Use o https://readme.so/pt para criar arquivos README decentes com linguagem markdown, um exemplo disso será visto no README do "Primeiro-Projeto-Java", use WINDOWS + . para usar emojis!

git add 'arquivo.txt' / é usado para adicionar arquivos ou mudanças ao "stage" (área de preparação), deixando-os prontos para serem incluídos no próximo commit. Em resumo, ele coloca suas alterações sob rastreamento do Git, git add . adiciona TODOS os arquivos

git commit / é usado para criar um commit, que registra as alterações preparadas na área de stage no histórico do repositório. O -m permite que você inclua uma mensagem descritiva diretamente no comando, explicando o que foi alterado. É uma prática recomendada escrever mensagens claras e informativas para facilitar o entendimento no futuro. git commit -m "Adiciona funcionalidade X ao projeto"

git log / O comando git log é usado para visualizar o histórico de commits do repositório. Ele lista os commits feitos, mostrando informações como o autor, a data e a mensagem associada a cada commit. É uma maneira de revisar o progresso do projeto, possui variações que incluem 1 linha ou mais, pesquise!

touch arquivo.txt /  usado principalmente em sistemas baseados em Unix (como Linux e macOS) para criar arquivos vazios ou atualizar a data e hora de modificação de um arquivo existente.

O git reconhece pastas vazias, alguns projetos possuem o arquivo gitkeep.txt dentro de diretórios, isso serve para o git reconhecer os diretórios

Desfazendo alterações 

Vamos supor que você deu git init na pasta errada, era pra ser  /Nova pasta, mas você colocou /Nova pasta/.git/, para remover isso basta usar
rm - rf .git
e o sistema voltará para Nova

Se apagarmos ou alterarmos um arquivo o git status indicará a mudança! caso queiramos reverter ela basta usar
git restore arquivo.md
CUIDADO, ele descarta todas as alterações feitas localmente!

Alterar mensagem de commit (que por sua vez aparece no git log)
git commit --amend -m"mensagem nova!"

desfazer commit
git reset --soft 'hashcode'
git reset --mixed 'hashcode'
git reset --hard  'hashcode'

soft / Mantém as mudanças na área de stage (prontas para o próximo commit). Útil se você quer desfazer um commit mas preparar as mesmas alterações para um novo commit. Isso desfaz o último commit, mas deixa os arquivos prontos para serem commitados novamente.

mixed / Remove as alterações da área de stage, mas as mantém nos arquivos de trabalho. Útil se você quer fazer ajustes antes de preparar os arquivos novamente. Isso desfaz o commit e remove os arquivos da área de stage, mas mantém os arquivos modificados.

hard / Desfaz o commit e descarta completamente as alterações nos arquivos. Desfaz o commit e descarta completamente as alterações nos arquivos. Isso desfaz o último commit e retorna o repositório ao estado anterior, descartando todas as mudanças

git reflog / é usado para visualizar o histórico de referências de um repositório. Ele exibe uma lista de alterações feitas nas referências do Git (como commits, resets, merges, etc.), permitindo que você veja e recupere estados anteriores mesmo que tenham sido descartados do log normal. Ele ajuda a rastrear commits "perdidos" ou que foram sobrescritos. Pode ser usado para recuperar alterações depois de comandos como git reset --hard. (Cima = mais recente, baixo = menos recente!)

Forçar alterações nos commits pode causar problemas. É recomendado corrigir os problemas criando um novo commit!

Abrir um repositório no github e apertar a tecla '.' vai abrir o projeto em um 'vscode online'!

branches
Ou branch é uma ramificação do projeto, um ponteiro móvel para um commit no histórico do repositório, quando você cria uma nova branch a partir de outra existente, a nova se inicia apontando para o mesmo commit da branch que estava quando foi 

commit 0 <-- commit 1 <-- commit 2(branch main)

a branch aponta para o commit 2, mas ele por si só aponta para o commit anterior
Quando se trabalha com múltiplas branches em um repositório Git, cada branch representa uma linha de desenvolvimento independente. Isso permite que diferentes alterações ou funcionalidades sejam desenvolvidas paralelamente sem interferir nas outras. Aqui está como funciona, Cada branch tem seu próprio ponteiro para um commit. Por exemplo:

main (commit 5) <-- commit 4 <-- commit 3
feature-x (commit 6) <-- commit 4 <-- commit 3

Nesse caso, main e feature-x compartilham parte do histórico, mas depois divergem

git checkout / é usado principalmente para trocar entre branches ou restaurar arquivos, mas pode ter várias funcionalidades dependendo do contexto. Aqui estão os usos mais comuns:

Trocar entre branches: git checkout nome-da-branch

Criar e mudar para uma nova branch: git checkout -b nova-

Restaurar arquivos ao estado de um commit específico:
git checkout HEAD arquivo.txt
Isso restaura o arquivo ao último estado commitado.

Restaurar o estado de todo o diretório:
Caso queira desfazer todas as alterações não commitadas
git checkout HEAD .

git merge / O git merge serve para integrar as mudanças de uma branch em outra. Ele preserva o histórico de commits e une os trabalhos de diferentes desenvolvedores ou funcionalidades.
- Se não houver novos commits na branch de destino, o Fast-forward Merge é usado: ele simplesmente avança o ponteiro da branch sem criar um novo commit.
- Caso ambas as branches tenham novos commits, um Merge Commit é criado para registrar a combinação de mudanças.
- Se houver alterações conflitantes (ex.: o mesmo arquivo editado em ambas as branches), o Git solicita que você resolva manualmente antes de concluir o merge.

Exemplo básico:
git checkout main
git merge feature-x

Aqui, a branch feature-x será mesclada na main.

git fetch / O comando git fetch é usado para baixar atualizações de branches remotas (como commits, tags e metadados) para o repositório local, sem alterar as branches locais ou fazer merges. Ele sincroniza o repositório local com o remoto, permitindo que você veja as mudanças antes de aplicá-las ou integrá-las. Por exemplo, após um git fetch, você pode comparar as diferenças ou decidir fazer um merge ou rebase manualmente 

Para buscar de uma branch remota específica:
git fetch origin nome-da-branch

Para buscar de um repositório remoto específico (caso você tenha configurado mais de um):
git fetch nome-do-remoto

Por padrão, o git fetch pega todas as atualizações do repositório remoto associado (geralmente chamado de origin). Isso não altera sua branch local até que você decida aplicar as mudanças, como com git merge ou git pull.

Se criam uma issue de número 1, ao arrumarmos e darmos commit na solução do problema, usamos fix #1 no nome do commit, dessa forma corrigimos a issue de número 1


                Sintaxe Java (Só vou anotar o que não sei/lembro)


Cuidado com o CamelCase e etc, essas paradas de nomeação de classes, arquivos e etc. Normalmente variáveis tipo FINAL, PI, EXEMPLO (toda em maíuscula) indicam variáveis que não podem ser alteradas, uma variável int no estilo ANO_2000 por si só já indica que é 2000 e não deve ser alteradas

Começo de variáveis: letras, $, _ 

expressão Final em variável indica que ela não pode ser alterada = constante!

Nomeação de pacotes: imagine uma empresa chamada HyperTech, ela possui vários setores, se o setor de comercio for fazer um projeto, seria legal usar esse padrão
com.hypertech.'nomeDoProjeto'
com de comercio, e por ai vai, e podemos ter 
com.hypertech.'nomeDoProjeto'.app pra inicializar
com.hypertech.'nomeDoProjeto'.modelo pra por as classes de modelo
com.hypertech.'nomeDoProjeto'.util para guardar os utilitários
com.hypertech.'nomeDoProjeto'.services com regras de negócio e serviço
A CONVENÇÃO VARIA DE EMPRESA PARA EMPRESA

e por ai vai, os pacotes (pastas) servem para ajudar a organizar os dados!

JavaBeans são componentes reutilizáveis da plataforma Java que encapsulam dados e lógica de negócios, facilitando a comunicação entre diferentes partes de uma aplicação

Variável no plural só se for um arrray de coisas

Funções com nomes de verbo, concluirProcessamento, Somar e por ai vai

float se encerra com F, float pi = 3.14F (f ou F)

JavaDoc é uma ferramenta utilizada para gerar documentação de código em Java com base em comentários no formato especial, facilitando a leitura e compreensão das funcionalidades de uma aplicação.

pra executar app fora da IDE é só achar a pasta bin com o .class que queremos rodar através do poweshell ou ms-dos e dar 'java exemplo' sem o .class

Quando você usa o comando javac para compilar um arquivo-fonte Java (.java), ele gera um arquivo de bytecode Java (.class). Esse arquivo .class contém o código que a Máquina Virtual Java (JVM) pode interpretar e executar.
Se, por exemplo, você tiver um arquivo Programa.java, ao rodar javac Programa.java, o compilador criará Programa.class. Depois, você pode executar esse programa com java Programa.

- Recebendo Argumentos: O método main define um parâmetro String[] args, que é um array de strings contendo os argumentos passados quando o programa é executado.
- Atribuição de Valores: O programa extrai os valores dos argumentos fornecidos:- args[0]: O primeiro argumento é armazenado na variável nome.
- args[1]: O segundo argumento é armazenado na variável sobrenome.
- args[2]: O terceiro argumento, que representa a idade, é convertido para um número inteiro (int).
- args[3]: O quarto argumento, que representa a altura, é convertido para um número decimal (double).

- Exibição na Tela: Utilizando System.out.println(), o programa imprime:- Uma saudação com o nome e sobrenome.
- A idade informada.
- A altura informada em centímetros.

EXEMPLO:
public class Programa {
    public static void main(String[] args) {
        // Obtendo os argumentos da linha de comando
        String nome = args[0];
        String sobrenome = args[1];
        int idade = Integer.parseInt(args[2]);
        double altura = Double.parseDouble(args[3]);

        // Exibindo as informações
        System.out.println("Olá, me chamo " + nome + " " + sobrenome);
        System.out.println("Tenho " + idade + " anos");
        System.out.println("Minha altura é " + altura + " cm");
    }
}
(é de se esperar que tudo seja String, então por isso o Parse nos outros tipos de dados!)

Se executarmos o programa com os seguintes argumentos:
java Programa Carlos Silva 25 175.5

Ele gerará a seguinte saída:
Ola, me chamo Carlos Silva
Tenho 25 anos
Minha altura é 175.5 cm

Dentro de um projeto Java no Vscode há uma pasta chamada .vscode que contém um arquivo launch.json, lá podemos definir os argumentos iniciais de execução de um programa!

Erros de programação são denominados bugs e o processo de encontrar e corrigir bugs é chamado de depuração ou debugging.

Existem duas grandes categorias que englobam a natureza do erro:

Erros de Sintaxe:
É um erro nas regras estabelecidas da linguagem:
Parênteses, chaves, colchetes que abrem mas não fecham.
Duas instruções sem um ponto-e-vírgula entre elas;
Uma palavra-chave sendo usada numa posição inesperada.

Erros de Semântica:
É um erro na "lógica do código", em sua semântica, o código está sintaticamente correto, porém não faz o que se esperava dele.
Tentar dividir um número por uma String ou por zero.
Atribuir um valor incoerente a um tipo de dado.
Tentar fechar um arquivo que não foi aberto.

Depuração/Debugging
Linguagens de alto nível tornam a depuração mais fácil, pois fornecem mais ferramentas para identificar erros, como o tratamento de exceções.

Os depuradores funcionam assumindo o controle do tempo de execução de um programa e permitindo que você o observe e controle. Para fazer isso, ele mostra a pilha do programa e permite que você a atravesse em qualquer direção. Quando você está em um depurador, obtém uma imagem mais completa de um quadro de pilha do que quando olha os rastreamentos de pilha em uma mensagem de log.

Pilha de Execução de um Programa Java/Stack Trace
Pilha de Execução:
Toda invocação de método é empilhada em uma estrutura de dados que isola a área de memória de cada um. Quando um método termina (retorna), ele volta para o método que o invocou.

Stack Trace:
É a matriz onde encontramos a pilha de excecução da exceção. Em outras palavras, podemos dizer que o rastreamento da pilha busca (rastreio) para a próxima linha onde a exceção pode surgir.

Lemos a stack trace de baixo para cima!

Tread.dumpStack() imprime o rastreamento da pilha da thread atual no fluxo de erro padrão. Isso é útil para depuração, pois permite verificar onde uma thread está sendo executada em determinado momento.

Breakpoints são essenciais para depuração em Java! Eles permitem que você pause a execução do programa em um ponto específico e analise o estado das variáveis e do fluxo de execução. Aqui estão alguns passos para usá-los em um ambiente de desenvolvimento como o IntelliJ IDEA ou Eclipse:
- Definir um breakpoint – Clique na margem esquerda ao lado de uma linha de código onde deseja que a execução pare.
- Executar o programa no modo de depuração – Use a opção de "Debug" ao invés de "Run".
- Inspecionar variáveis – Quando o programa parar no breakpoint, você pode examinar valores de variáveis no painel de depuração.
- Passar pelas linhas – Use os comandos "Step Over", "Step Into" e "Step Out" para navegar pelo código.
- Modificar valores durante a execução – Alguns IDEs permitem alterar valores de variáveis no meio da execução para testar diferentes cenários.

 Esses comandos de depuração ajudam a navegar pelo código em um ambiente de debug. Aqui está o que cada um faz:

Step Over (F8 no IntelliJ IDEA, F6 no Eclipse): Avança para a próxima linha de código sem entrar em métodos chamados na linha atual. Se houver uma chamada de método, ele será executado inteiramente e o depurador passará para a próxima linha no mesmo escopo.

Step Into (F7 no IntelliJ IDEA, F5 no Eclipse): Entra no método chamado na linha atual, permitindo inspecionar sua execução linha por linha.

Force Step Into (Alt + Shift + F7 no IntelliJ IDEA): Ignora otimizações da IDE e entra até mesmo em métodos da biblioteca padrão ou código compilado.

Step Out (Shift + F8 no IntelliJ IDEA, F7 no Eclipse): Sai do método atual e retorna ao seu chamador, útil para concluir rapidamente um método e voltar ao nível superior.

Run to Cursor (Alt + F9 no IntelliJ IDEA, Ctrl + R no Eclipse): Continua a execução até o ponto onde o cursor está, sem a necessidade de um breakpoint.

O Evaluate Expression é uma ferramenta muito útil na depuração de código Java! Ele permite que você avalie expressões ou execute pequenas porções de código no contexto da execução atual do depurador, sem alterar o código-fonte.
Aqui estão alguns usos comuns:
- Verificar valores complexos – Você pode inserir qualquer expressão, como myObject.getSomeValue() e visualizar o resultado sem precisar imprimir no console.
- Modificar valores temporariamente – É possível alterar variáveis no meio da execução para testar diferentes cenários.
- Testar chamadas de métodos – Avalie um método antes de executá-lo no código principal, garantindo que ele retorna o valor esperado.
- Expressões booleanas – Confirme rapidamente se uma condição if será verdadeira ou falsa antes de prosseguir.

Ao debuggar pode ser necessário inserir dados no console, confirmar  e apertar em step over para seguir a lógica do programa

--
Jeito de aceitar vírgulas e pontos 

Scanner scanner = new Scanner(System.in);
System.out.print("Digite um número decimal: ");
String input = scanner.nextLine().replace(",", "."); // Lê como string e substitui vírgula por ponto

try {
    double numero = Double.parseDouble(input); // Faz o parse para Double
    System.out.println("Número convertido: " + numero);
} catch (NumberFormatException e) {
    System.out.println("Entrada inválida!");
}

só pegar o input como string trocar a , por . e dar um parse depois!